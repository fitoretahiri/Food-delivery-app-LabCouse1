{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSAsExpression = TSAsExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintBraced = tsPrintBraced;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\nexports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;\n\nfunction TSTypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n\n  if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    this.token(\",\");\n  }\n\n  this.token(\">\");\n}\n\nfunction TSTypeParameter(node) {\n  this.word(node.name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nfunction TSDeclareFunction(node) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this._functionHead(node);\n\n  this.token(\";\");\n}\n\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n\n  this.token(\";\");\n}\n\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.token(\".\");\n  this.print(node.right, node);\n}\n\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(\";\");\n}\n\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n\n  this.print(node.key, node);\n\n  if (node.computed) {\n    this.token(\"]\");\n  }\n\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n\n  this._parameters(node.parameters, node);\n\n  this.token(\"]\");\n  this.print(node.typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\n\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\n\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\n\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\n\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\n\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\n\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\n\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\n\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\n\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\n\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\n\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\n\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\n\nfunction TSThisType() {\n  this.word(\"this\");\n}\n\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(parameters, node);\n\n  this.token(\")\");\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType.typeAnnotation, node);\n}\n\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n\n  this.print(node.parameterName);\n\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n}\n\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  this.tsPrintBraced(members, node);\n}\n\nfunction tsPrintBraced(members, node) {\n  this.token(\"{\");\n\n  if (members.length) {\n    this.indent();\n    this.newline();\n\n    for (const member of members) {\n      this.print(member, node);\n      this.newline();\n    }\n\n    this.dedent();\n    this.rightBrace();\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction TSArrayType(node) {\n  this.print(node.elementType, node);\n  this.token(\"[]\");\n}\n\nfunction TSTupleType(node) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, node);\n  this.token(\"]\");\n}\n\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.token(\"?\");\n}\n\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType, node);\n}\n\nfunction TSUnionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, \"|\");\n}\n\nfunction TSIntersectionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(node, sep) {\n  this.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n\n  });\n}\n\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nfunction TSInferType(node) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\n\nfunction TSParenthesizedType(node) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.token(\"{\");\n  this.space();\n\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\n\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSAsExpression(node) {\n  const {\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, node);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation, node);\n  this.token(\">\");\n  this.space();\n  this.print(expression, node);\n}\n\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tsPrintBraced(members, node);\n}\n\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(\",\");\n}\n\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n\n  this.print(id, node);\n\n  if (!node.body) {\n    this.token(\";\");\n    return;\n  }\n\n  let body = node.body;\n\n  while (body.type === \"TSModuleDeclaration\") {\n    this.token(\".\");\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSModuleBlock(node) {\n  this.tsPrintBraced(node.body, node);\n}\n\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(argument, node);\n  this.token(\")\");\n\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier, node);\n  }\n\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\n\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference, node);\n  this.token(\";\");\n}\n\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.token(\"!\");\n}\n\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression, node);\n  this.token(\";\");\n}\n\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\n\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(parameters, node);\n\n  this.token(\")\");\n  const returnType = node.typeAnnotation;\n  this.print(returnType, node);\n}\n\nfunction tsPrintClassMemberModifiers(node, isField) {\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.override) {\n    this.word(\"override\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TSAnyKeyword","TSArrayType","TSAsExpression","TSBigIntKeyword","TSBooleanKeyword","TSCallSignatureDeclaration","TSConditionalType","TSConstructSignatureDeclaration","TSConstructorType","TSDeclareFunction","TSDeclareMethod","TSEnumDeclaration","TSEnumMember","TSExportAssignment","TSExpressionWithTypeArguments","TSExternalModuleReference","TSFunctionType","TSImportEqualsDeclaration","TSImportType","TSIndexSignature","TSIndexedAccessType","TSInferType","TSInterfaceBody","TSInterfaceDeclaration","TSIntersectionType","TSIntrinsicKeyword","TSLiteralType","TSMappedType","TSMethodSignature","TSModuleBlock","TSModuleDeclaration","TSNamedTupleMember","TSNamespaceExportDeclaration","TSNeverKeyword","TSNonNullExpression","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSOptionalType","TSParameterProperty","TSParenthesizedType","TSPropertySignature","TSQualifiedName","TSRestType","TSStringKeyword","TSSymbolKeyword","TSThisType","TSTupleType","TSTypeAliasDeclaration","TSTypeAnnotation","TSTypeAssertion","TSTypeLiteral","TSTypeOperator","TSTypeParameter","TSTypeParameterDeclaration","TSTypeParameterInstantiation","TSTypePredicate","TSTypeQuery","TSTypeReference","TSUndefinedKeyword","TSUnionType","TSUnknownKeyword","TSVoidKeyword","tsPrintBraced","tsPrintClassMemberModifiers","tsPrintFunctionOrConstructorType","tsPrintPropertyOrMethodName","tsPrintSignatureDeclarationBase","tsPrintTypeLiteralOrInterfaceBody","tsPrintUnionOrIntersectionType","node","token","space","optional","print","typeAnnotation","parent","printList","params","type","length","word","name","constraint","default","accessibility","readonly","_param","parameter","declare","_functionHead","_classMethodHead","left","right","initializer","computed","key","kind","static","isStatic","_parameters","parameters","abstract","typeParameters","returnType","typeName","asserts","parameterName","exprName","members","indent","newline","member","dedent","rightBrace","elementType","elementTypes","label","sep","printJoin","types","separator","checkType","extendsType","trueType","falseType","typeParameter","operator","objectType","indexType","nameType","tokenIfPlusMinus","self","tok","literal","expression","id","extends","extendz","body","const","isConst","global","argument","qualifier","isExport","moduleReference","isField","override"],"sources":["C:/Users/Arber/Documents/GitHub/Food-delivery-app-LabCouse1/Food-delivery-app-LabCouse1/front-end-code/node_modules/@babel/generator/lib/generators/typescript.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.TSAnyKeyword = TSAnyKeyword;\r\nexports.TSArrayType = TSArrayType;\r\nexports.TSAsExpression = TSAsExpression;\r\nexports.TSBigIntKeyword = TSBigIntKeyword;\r\nexports.TSBooleanKeyword = TSBooleanKeyword;\r\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\r\nexports.TSConditionalType = TSConditionalType;\r\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\r\nexports.TSConstructorType = TSConstructorType;\r\nexports.TSDeclareFunction = TSDeclareFunction;\r\nexports.TSDeclareMethod = TSDeclareMethod;\r\nexports.TSEnumDeclaration = TSEnumDeclaration;\r\nexports.TSEnumMember = TSEnumMember;\r\nexports.TSExportAssignment = TSExportAssignment;\r\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\r\nexports.TSExternalModuleReference = TSExternalModuleReference;\r\nexports.TSFunctionType = TSFunctionType;\r\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\r\nexports.TSImportType = TSImportType;\r\nexports.TSIndexSignature = TSIndexSignature;\r\nexports.TSIndexedAccessType = TSIndexedAccessType;\r\nexports.TSInferType = TSInferType;\r\nexports.TSInterfaceBody = TSInterfaceBody;\r\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\r\nexports.TSIntersectionType = TSIntersectionType;\r\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\r\nexports.TSLiteralType = TSLiteralType;\r\nexports.TSMappedType = TSMappedType;\r\nexports.TSMethodSignature = TSMethodSignature;\r\nexports.TSModuleBlock = TSModuleBlock;\r\nexports.TSModuleDeclaration = TSModuleDeclaration;\r\nexports.TSNamedTupleMember = TSNamedTupleMember;\r\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\r\nexports.TSNeverKeyword = TSNeverKeyword;\r\nexports.TSNonNullExpression = TSNonNullExpression;\r\nexports.TSNullKeyword = TSNullKeyword;\r\nexports.TSNumberKeyword = TSNumberKeyword;\r\nexports.TSObjectKeyword = TSObjectKeyword;\r\nexports.TSOptionalType = TSOptionalType;\r\nexports.TSParameterProperty = TSParameterProperty;\r\nexports.TSParenthesizedType = TSParenthesizedType;\r\nexports.TSPropertySignature = TSPropertySignature;\r\nexports.TSQualifiedName = TSQualifiedName;\r\nexports.TSRestType = TSRestType;\r\nexports.TSStringKeyword = TSStringKeyword;\r\nexports.TSSymbolKeyword = TSSymbolKeyword;\r\nexports.TSThisType = TSThisType;\r\nexports.TSTupleType = TSTupleType;\r\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\r\nexports.TSTypeAnnotation = TSTypeAnnotation;\r\nexports.TSTypeAssertion = TSTypeAssertion;\r\nexports.TSTypeLiteral = TSTypeLiteral;\r\nexports.TSTypeOperator = TSTypeOperator;\r\nexports.TSTypeParameter = TSTypeParameter;\r\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\r\nexports.TSTypePredicate = TSTypePredicate;\r\nexports.TSTypeQuery = TSTypeQuery;\r\nexports.TSTypeReference = TSTypeReference;\r\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\r\nexports.TSUnionType = TSUnionType;\r\nexports.TSUnknownKeyword = TSUnknownKeyword;\r\nexports.TSVoidKeyword = TSVoidKeyword;\r\nexports.tsPrintBraced = tsPrintBraced;\r\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\r\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\r\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\r\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\r\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\r\nexports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;\r\n\r\nfunction TSTypeAnnotation(node) {\r\n  this.token(\":\");\r\n  this.space();\r\n  if (node.optional) this.token(\"?\");\r\n  this.print(node.typeAnnotation, node);\r\n}\r\n\r\nfunction TSTypeParameterInstantiation(node, parent) {\r\n  this.token(\"<\");\r\n  this.printList(node.params, node, {});\r\n\r\n  if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\r\n    this.token(\",\");\r\n  }\r\n\r\n  this.token(\">\");\r\n}\r\n\r\nfunction TSTypeParameter(node) {\r\n  this.word(node.name);\r\n\r\n  if (node.constraint) {\r\n    this.space();\r\n    this.word(\"extends\");\r\n    this.space();\r\n    this.print(node.constraint, node);\r\n  }\r\n\r\n  if (node.default) {\r\n    this.space();\r\n    this.token(\"=\");\r\n    this.space();\r\n    this.print(node.default, node);\r\n  }\r\n}\r\n\r\nfunction TSParameterProperty(node) {\r\n  if (node.accessibility) {\r\n    this.word(node.accessibility);\r\n    this.space();\r\n  }\r\n\r\n  if (node.readonly) {\r\n    this.word(\"readonly\");\r\n    this.space();\r\n  }\r\n\r\n  this._param(node.parameter);\r\n}\r\n\r\nfunction TSDeclareFunction(node) {\r\n  if (node.declare) {\r\n    this.word(\"declare\");\r\n    this.space();\r\n  }\r\n\r\n  this._functionHead(node);\r\n\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSDeclareMethod(node) {\r\n  this._classMethodHead(node);\r\n\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSQualifiedName(node) {\r\n  this.print(node.left, node);\r\n  this.token(\".\");\r\n  this.print(node.right, node);\r\n}\r\n\r\nfunction TSCallSignatureDeclaration(node) {\r\n  this.tsPrintSignatureDeclarationBase(node);\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSConstructSignatureDeclaration(node) {\r\n  this.word(\"new\");\r\n  this.space();\r\n  this.tsPrintSignatureDeclarationBase(node);\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSPropertySignature(node) {\r\n  const {\r\n    readonly,\r\n    initializer\r\n  } = node;\r\n\r\n  if (readonly) {\r\n    this.word(\"readonly\");\r\n    this.space();\r\n  }\r\n\r\n  this.tsPrintPropertyOrMethodName(node);\r\n  this.print(node.typeAnnotation, node);\r\n\r\n  if (initializer) {\r\n    this.space();\r\n    this.token(\"=\");\r\n    this.space();\r\n    this.print(initializer, node);\r\n  }\r\n\r\n  this.token(\";\");\r\n}\r\n\r\nfunction tsPrintPropertyOrMethodName(node) {\r\n  if (node.computed) {\r\n    this.token(\"[\");\r\n  }\r\n\r\n  this.print(node.key, node);\r\n\r\n  if (node.computed) {\r\n    this.token(\"]\");\r\n  }\r\n\r\n  if (node.optional) {\r\n    this.token(\"?\");\r\n  }\r\n}\r\n\r\nfunction TSMethodSignature(node) {\r\n  const {\r\n    kind\r\n  } = node;\r\n\r\n  if (kind === \"set\" || kind === \"get\") {\r\n    this.word(kind);\r\n    this.space();\r\n  }\r\n\r\n  this.tsPrintPropertyOrMethodName(node);\r\n  this.tsPrintSignatureDeclarationBase(node);\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSIndexSignature(node) {\r\n  const {\r\n    readonly,\r\n    static: isStatic\r\n  } = node;\r\n\r\n  if (isStatic) {\r\n    this.word(\"static\");\r\n    this.space();\r\n  }\r\n\r\n  if (readonly) {\r\n    this.word(\"readonly\");\r\n    this.space();\r\n  }\r\n\r\n  this.token(\"[\");\r\n\r\n  this._parameters(node.parameters, node);\r\n\r\n  this.token(\"]\");\r\n  this.print(node.typeAnnotation, node);\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSAnyKeyword() {\r\n  this.word(\"any\");\r\n}\r\n\r\nfunction TSBigIntKeyword() {\r\n  this.word(\"bigint\");\r\n}\r\n\r\nfunction TSUnknownKeyword() {\r\n  this.word(\"unknown\");\r\n}\r\n\r\nfunction TSNumberKeyword() {\r\n  this.word(\"number\");\r\n}\r\n\r\nfunction TSObjectKeyword() {\r\n  this.word(\"object\");\r\n}\r\n\r\nfunction TSBooleanKeyword() {\r\n  this.word(\"boolean\");\r\n}\r\n\r\nfunction TSStringKeyword() {\r\n  this.word(\"string\");\r\n}\r\n\r\nfunction TSSymbolKeyword() {\r\n  this.word(\"symbol\");\r\n}\r\n\r\nfunction TSVoidKeyword() {\r\n  this.word(\"void\");\r\n}\r\n\r\nfunction TSUndefinedKeyword() {\r\n  this.word(\"undefined\");\r\n}\r\n\r\nfunction TSNullKeyword() {\r\n  this.word(\"null\");\r\n}\r\n\r\nfunction TSNeverKeyword() {\r\n  this.word(\"never\");\r\n}\r\n\r\nfunction TSIntrinsicKeyword() {\r\n  this.word(\"intrinsic\");\r\n}\r\n\r\nfunction TSThisType() {\r\n  this.word(\"this\");\r\n}\r\n\r\nfunction TSFunctionType(node) {\r\n  this.tsPrintFunctionOrConstructorType(node);\r\n}\r\n\r\nfunction TSConstructorType(node) {\r\n  if (node.abstract) {\r\n    this.word(\"abstract\");\r\n    this.space();\r\n  }\r\n\r\n  this.word(\"new\");\r\n  this.space();\r\n  this.tsPrintFunctionOrConstructorType(node);\r\n}\r\n\r\nfunction tsPrintFunctionOrConstructorType(node) {\r\n  const {\r\n    typeParameters\r\n  } = node;\r\n  const parameters = node.parameters;\r\n  this.print(typeParameters, node);\r\n  this.token(\"(\");\r\n\r\n  this._parameters(parameters, node);\r\n\r\n  this.token(\")\");\r\n  this.space();\r\n  this.token(\"=>\");\r\n  this.space();\r\n  const returnType = node.typeAnnotation;\r\n  this.print(returnType.typeAnnotation, node);\r\n}\r\n\r\nfunction TSTypeReference(node) {\r\n  this.print(node.typeName, node);\r\n  this.print(node.typeParameters, node);\r\n}\r\n\r\nfunction TSTypePredicate(node) {\r\n  if (node.asserts) {\r\n    this.word(\"asserts\");\r\n    this.space();\r\n  }\r\n\r\n  this.print(node.parameterName);\r\n\r\n  if (node.typeAnnotation) {\r\n    this.space();\r\n    this.word(\"is\");\r\n    this.space();\r\n    this.print(node.typeAnnotation.typeAnnotation);\r\n  }\r\n}\r\n\r\nfunction TSTypeQuery(node) {\r\n  this.word(\"typeof\");\r\n  this.space();\r\n  this.print(node.exprName);\r\n}\r\n\r\nfunction TSTypeLiteral(node) {\r\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\r\n}\r\n\r\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\r\n  this.tsPrintBraced(members, node);\r\n}\r\n\r\nfunction tsPrintBraced(members, node) {\r\n  this.token(\"{\");\r\n\r\n  if (members.length) {\r\n    this.indent();\r\n    this.newline();\r\n\r\n    for (const member of members) {\r\n      this.print(member, node);\r\n      this.newline();\r\n    }\r\n\r\n    this.dedent();\r\n    this.rightBrace();\r\n  } else {\r\n    this.token(\"}\");\r\n  }\r\n}\r\n\r\nfunction TSArrayType(node) {\r\n  this.print(node.elementType, node);\r\n  this.token(\"[]\");\r\n}\r\n\r\nfunction TSTupleType(node) {\r\n  this.token(\"[\");\r\n  this.printList(node.elementTypes, node);\r\n  this.token(\"]\");\r\n}\r\n\r\nfunction TSOptionalType(node) {\r\n  this.print(node.typeAnnotation, node);\r\n  this.token(\"?\");\r\n}\r\n\r\nfunction TSRestType(node) {\r\n  this.token(\"...\");\r\n  this.print(node.typeAnnotation, node);\r\n}\r\n\r\nfunction TSNamedTupleMember(node) {\r\n  this.print(node.label, node);\r\n  if (node.optional) this.token(\"?\");\r\n  this.token(\":\");\r\n  this.space();\r\n  this.print(node.elementType, node);\r\n}\r\n\r\nfunction TSUnionType(node) {\r\n  this.tsPrintUnionOrIntersectionType(node, \"|\");\r\n}\r\n\r\nfunction TSIntersectionType(node) {\r\n  this.tsPrintUnionOrIntersectionType(node, \"&\");\r\n}\r\n\r\nfunction tsPrintUnionOrIntersectionType(node, sep) {\r\n  this.printJoin(node.types, node, {\r\n    separator() {\r\n      this.space();\r\n      this.token(sep);\r\n      this.space();\r\n    }\r\n\r\n  });\r\n}\r\n\r\nfunction TSConditionalType(node) {\r\n  this.print(node.checkType);\r\n  this.space();\r\n  this.word(\"extends\");\r\n  this.space();\r\n  this.print(node.extendsType);\r\n  this.space();\r\n  this.token(\"?\");\r\n  this.space();\r\n  this.print(node.trueType);\r\n  this.space();\r\n  this.token(\":\");\r\n  this.space();\r\n  this.print(node.falseType);\r\n}\r\n\r\nfunction TSInferType(node) {\r\n  this.token(\"infer\");\r\n  this.space();\r\n  this.print(node.typeParameter);\r\n}\r\n\r\nfunction TSParenthesizedType(node) {\r\n  this.token(\"(\");\r\n  this.print(node.typeAnnotation, node);\r\n  this.token(\")\");\r\n}\r\n\r\nfunction TSTypeOperator(node) {\r\n  this.word(node.operator);\r\n  this.space();\r\n  this.print(node.typeAnnotation, node);\r\n}\r\n\r\nfunction TSIndexedAccessType(node) {\r\n  this.print(node.objectType, node);\r\n  this.token(\"[\");\r\n  this.print(node.indexType, node);\r\n  this.token(\"]\");\r\n}\r\n\r\nfunction TSMappedType(node) {\r\n  const {\r\n    nameType,\r\n    optional,\r\n    readonly,\r\n    typeParameter\r\n  } = node;\r\n  this.token(\"{\");\r\n  this.space();\r\n\r\n  if (readonly) {\r\n    tokenIfPlusMinus(this, readonly);\r\n    this.word(\"readonly\");\r\n    this.space();\r\n  }\r\n\r\n  this.token(\"[\");\r\n  this.word(typeParameter.name);\r\n  this.space();\r\n  this.word(\"in\");\r\n  this.space();\r\n  this.print(typeParameter.constraint, typeParameter);\r\n\r\n  if (nameType) {\r\n    this.space();\r\n    this.word(\"as\");\r\n    this.space();\r\n    this.print(nameType, node);\r\n  }\r\n\r\n  this.token(\"]\");\r\n\r\n  if (optional) {\r\n    tokenIfPlusMinus(this, optional);\r\n    this.token(\"?\");\r\n  }\r\n\r\n  this.token(\":\");\r\n  this.space();\r\n  this.print(node.typeAnnotation, node);\r\n  this.space();\r\n  this.token(\"}\");\r\n}\r\n\r\nfunction tokenIfPlusMinus(self, tok) {\r\n  if (tok !== true) {\r\n    self.token(tok);\r\n  }\r\n}\r\n\r\nfunction TSLiteralType(node) {\r\n  this.print(node.literal, node);\r\n}\r\n\r\nfunction TSExpressionWithTypeArguments(node) {\r\n  this.print(node.expression, node);\r\n  this.print(node.typeParameters, node);\r\n}\r\n\r\nfunction TSInterfaceDeclaration(node) {\r\n  const {\r\n    declare,\r\n    id,\r\n    typeParameters,\r\n    extends: extendz,\r\n    body\r\n  } = node;\r\n\r\n  if (declare) {\r\n    this.word(\"declare\");\r\n    this.space();\r\n  }\r\n\r\n  this.word(\"interface\");\r\n  this.space();\r\n  this.print(id, node);\r\n  this.print(typeParameters, node);\r\n\r\n  if (extendz != null && extendz.length) {\r\n    this.space();\r\n    this.word(\"extends\");\r\n    this.space();\r\n    this.printList(extendz, node);\r\n  }\r\n\r\n  this.space();\r\n  this.print(body, node);\r\n}\r\n\r\nfunction TSInterfaceBody(node) {\r\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\r\n}\r\n\r\nfunction TSTypeAliasDeclaration(node) {\r\n  const {\r\n    declare,\r\n    id,\r\n    typeParameters,\r\n    typeAnnotation\r\n  } = node;\r\n\r\n  if (declare) {\r\n    this.word(\"declare\");\r\n    this.space();\r\n  }\r\n\r\n  this.word(\"type\");\r\n  this.space();\r\n  this.print(id, node);\r\n  this.print(typeParameters, node);\r\n  this.space();\r\n  this.token(\"=\");\r\n  this.space();\r\n  this.print(typeAnnotation, node);\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSAsExpression(node) {\r\n  const {\r\n    expression,\r\n    typeAnnotation\r\n  } = node;\r\n  this.print(expression, node);\r\n  this.space();\r\n  this.word(\"as\");\r\n  this.space();\r\n  this.print(typeAnnotation, node);\r\n}\r\n\r\nfunction TSTypeAssertion(node) {\r\n  const {\r\n    typeAnnotation,\r\n    expression\r\n  } = node;\r\n  this.token(\"<\");\r\n  this.print(typeAnnotation, node);\r\n  this.token(\">\");\r\n  this.space();\r\n  this.print(expression, node);\r\n}\r\n\r\nfunction TSEnumDeclaration(node) {\r\n  const {\r\n    declare,\r\n    const: isConst,\r\n    id,\r\n    members\r\n  } = node;\r\n\r\n  if (declare) {\r\n    this.word(\"declare\");\r\n    this.space();\r\n  }\r\n\r\n  if (isConst) {\r\n    this.word(\"const\");\r\n    this.space();\r\n  }\r\n\r\n  this.word(\"enum\");\r\n  this.space();\r\n  this.print(id, node);\r\n  this.space();\r\n  this.tsPrintBraced(members, node);\r\n}\r\n\r\nfunction TSEnumMember(node) {\r\n  const {\r\n    id,\r\n    initializer\r\n  } = node;\r\n  this.print(id, node);\r\n\r\n  if (initializer) {\r\n    this.space();\r\n    this.token(\"=\");\r\n    this.space();\r\n    this.print(initializer, node);\r\n  }\r\n\r\n  this.token(\",\");\r\n}\r\n\r\nfunction TSModuleDeclaration(node) {\r\n  const {\r\n    declare,\r\n    id\r\n  } = node;\r\n\r\n  if (declare) {\r\n    this.word(\"declare\");\r\n    this.space();\r\n  }\r\n\r\n  if (!node.global) {\r\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\r\n    this.space();\r\n  }\r\n\r\n  this.print(id, node);\r\n\r\n  if (!node.body) {\r\n    this.token(\";\");\r\n    return;\r\n  }\r\n\r\n  let body = node.body;\r\n\r\n  while (body.type === \"TSModuleDeclaration\") {\r\n    this.token(\".\");\r\n    this.print(body.id, body);\r\n    body = body.body;\r\n  }\r\n\r\n  this.space();\r\n  this.print(body, node);\r\n}\r\n\r\nfunction TSModuleBlock(node) {\r\n  this.tsPrintBraced(node.body, node);\r\n}\r\n\r\nfunction TSImportType(node) {\r\n  const {\r\n    argument,\r\n    qualifier,\r\n    typeParameters\r\n  } = node;\r\n  this.word(\"import\");\r\n  this.token(\"(\");\r\n  this.print(argument, node);\r\n  this.token(\")\");\r\n\r\n  if (qualifier) {\r\n    this.token(\".\");\r\n    this.print(qualifier, node);\r\n  }\r\n\r\n  if (typeParameters) {\r\n    this.print(typeParameters, node);\r\n  }\r\n}\r\n\r\nfunction TSImportEqualsDeclaration(node) {\r\n  const {\r\n    isExport,\r\n    id,\r\n    moduleReference\r\n  } = node;\r\n\r\n  if (isExport) {\r\n    this.word(\"export\");\r\n    this.space();\r\n  }\r\n\r\n  this.word(\"import\");\r\n  this.space();\r\n  this.print(id, node);\r\n  this.space();\r\n  this.token(\"=\");\r\n  this.space();\r\n  this.print(moduleReference, node);\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSExternalModuleReference(node) {\r\n  this.token(\"require(\");\r\n  this.print(node.expression, node);\r\n  this.token(\")\");\r\n}\r\n\r\nfunction TSNonNullExpression(node) {\r\n  this.print(node.expression, node);\r\n  this.token(\"!\");\r\n}\r\n\r\nfunction TSExportAssignment(node) {\r\n  this.word(\"export\");\r\n  this.space();\r\n  this.token(\"=\");\r\n  this.space();\r\n  this.print(node.expression, node);\r\n  this.token(\";\");\r\n}\r\n\r\nfunction TSNamespaceExportDeclaration(node) {\r\n  this.word(\"export\");\r\n  this.space();\r\n  this.word(\"as\");\r\n  this.space();\r\n  this.word(\"namespace\");\r\n  this.space();\r\n  this.print(node.id, node);\r\n}\r\n\r\nfunction tsPrintSignatureDeclarationBase(node) {\r\n  const {\r\n    typeParameters\r\n  } = node;\r\n  const parameters = node.parameters;\r\n  this.print(typeParameters, node);\r\n  this.token(\"(\");\r\n\r\n  this._parameters(parameters, node);\r\n\r\n  this.token(\")\");\r\n  const returnType = node.typeAnnotation;\r\n  this.print(returnType, node);\r\n}\r\n\r\nfunction tsPrintClassMemberModifiers(node, isField) {\r\n  if (isField && node.declare) {\r\n    this.word(\"declare\");\r\n    this.space();\r\n  }\r\n\r\n  if (node.accessibility) {\r\n    this.word(node.accessibility);\r\n    this.space();\r\n  }\r\n\r\n  if (node.static) {\r\n    this.word(\"static\");\r\n    this.space();\r\n  }\r\n\r\n  if (node.override) {\r\n    this.word(\"override\");\r\n    this.space();\r\n  }\r\n\r\n  if (node.abstract) {\r\n    this.word(\"abstract\");\r\n    this.space();\r\n  }\r\n\r\n  if (isField && node.readonly) {\r\n    this.word(\"readonly\");\r\n    this.space();\r\n  }\r\n}"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,YAAR,GAAuBA,YAAvB;AACAF,OAAO,CAACG,WAAR,GAAsBA,WAAtB;AACAH,OAAO,CAACI,cAAR,GAAyBA,cAAzB;AACAJ,OAAO,CAACK,eAAR,GAA0BA,eAA1B;AACAL,OAAO,CAACM,gBAAR,GAA2BA,gBAA3B;AACAN,OAAO,CAACO,0BAAR,GAAqCA,0BAArC;AACAP,OAAO,CAACQ,iBAAR,GAA4BA,iBAA5B;AACAR,OAAO,CAACS,+BAAR,GAA0CA,+BAA1C;AACAT,OAAO,CAACU,iBAAR,GAA4BA,iBAA5B;AACAV,OAAO,CAACW,iBAAR,GAA4BA,iBAA5B;AACAX,OAAO,CAACY,eAAR,GAA0BA,eAA1B;AACAZ,OAAO,CAACa,iBAAR,GAA4BA,iBAA5B;AACAb,OAAO,CAACc,YAAR,GAAuBA,YAAvB;AACAd,OAAO,CAACe,kBAAR,GAA6BA,kBAA7B;AACAf,OAAO,CAACgB,6BAAR,GAAwCA,6BAAxC;AACAhB,OAAO,CAACiB,yBAAR,GAAoCA,yBAApC;AACAjB,OAAO,CAACkB,cAAR,GAAyBA,cAAzB;AACAlB,OAAO,CAACmB,yBAAR,GAAoCA,yBAApC;AACAnB,OAAO,CAACoB,YAAR,GAAuBA,YAAvB;AACApB,OAAO,CAACqB,gBAAR,GAA2BA,gBAA3B;AACArB,OAAO,CAACsB,mBAAR,GAA8BA,mBAA9B;AACAtB,OAAO,CAACuB,WAAR,GAAsBA,WAAtB;AACAvB,OAAO,CAACwB,eAAR,GAA0BA,eAA1B;AACAxB,OAAO,CAACyB,sBAAR,GAAiCA,sBAAjC;AACAzB,OAAO,CAAC0B,kBAAR,GAA6BA,kBAA7B;AACA1B,OAAO,CAAC2B,kBAAR,GAA6BA,kBAA7B;AACA3B,OAAO,CAAC4B,aAAR,GAAwBA,aAAxB;AACA5B,OAAO,CAAC6B,YAAR,GAAuBA,YAAvB;AACA7B,OAAO,CAAC8B,iBAAR,GAA4BA,iBAA5B;AACA9B,OAAO,CAAC+B,aAAR,GAAwBA,aAAxB;AACA/B,OAAO,CAACgC,mBAAR,GAA8BA,mBAA9B;AACAhC,OAAO,CAACiC,kBAAR,GAA6BA,kBAA7B;AACAjC,OAAO,CAACkC,4BAAR,GAAuCA,4BAAvC;AACAlC,OAAO,CAACmC,cAAR,GAAyBA,cAAzB;AACAnC,OAAO,CAACoC,mBAAR,GAA8BA,mBAA9B;AACApC,OAAO,CAACqC,aAAR,GAAwBA,aAAxB;AACArC,OAAO,CAACsC,eAAR,GAA0BA,eAA1B;AACAtC,OAAO,CAACuC,eAAR,GAA0BA,eAA1B;AACAvC,OAAO,CAACwC,cAAR,GAAyBA,cAAzB;AACAxC,OAAO,CAACyC,mBAAR,GAA8BA,mBAA9B;AACAzC,OAAO,CAAC0C,mBAAR,GAA8BA,mBAA9B;AACA1C,OAAO,CAAC2C,mBAAR,GAA8BA,mBAA9B;AACA3C,OAAO,CAAC4C,eAAR,GAA0BA,eAA1B;AACA5C,OAAO,CAAC6C,UAAR,GAAqBA,UAArB;AACA7C,OAAO,CAAC8C,eAAR,GAA0BA,eAA1B;AACA9C,OAAO,CAAC+C,eAAR,GAA0BA,eAA1B;AACA/C,OAAO,CAACgD,UAAR,GAAqBA,UAArB;AACAhD,OAAO,CAACiD,WAAR,GAAsBA,WAAtB;AACAjD,OAAO,CAACkD,sBAAR,GAAiCA,sBAAjC;AACAlD,OAAO,CAACmD,gBAAR,GAA2BA,gBAA3B;AACAnD,OAAO,CAACoD,eAAR,GAA0BA,eAA1B;AACApD,OAAO,CAACqD,aAAR,GAAwBA,aAAxB;AACArD,OAAO,CAACsD,cAAR,GAAyBA,cAAzB;AACAtD,OAAO,CAACuD,eAAR,GAA0BA,eAA1B;AACAvD,OAAO,CAACwD,0BAAR,GAAqCxD,OAAO,CAACyD,4BAAR,GAAuCA,4BAA5E;AACAzD,OAAO,CAAC0D,eAAR,GAA0BA,eAA1B;AACA1D,OAAO,CAAC2D,WAAR,GAAsBA,WAAtB;AACA3D,OAAO,CAAC4D,eAAR,GAA0BA,eAA1B;AACA5D,OAAO,CAAC6D,kBAAR,GAA6BA,kBAA7B;AACA7D,OAAO,CAAC8D,WAAR,GAAsBA,WAAtB;AACA9D,OAAO,CAAC+D,gBAAR,GAA2BA,gBAA3B;AACA/D,OAAO,CAACgE,aAAR,GAAwBA,aAAxB;AACAhE,OAAO,CAACiE,aAAR,GAAwBA,aAAxB;AACAjE,OAAO,CAACkE,2BAAR,GAAsCA,2BAAtC;AACAlE,OAAO,CAACmE,gCAAR,GAA2CA,gCAA3C;AACAnE,OAAO,CAACoE,2BAAR,GAAsCA,2BAAtC;AACApE,OAAO,CAACqE,+BAAR,GAA0CA,+BAA1C;AACArE,OAAO,CAACsE,iCAAR,GAA4CA,iCAA5C;AACAtE,OAAO,CAACuE,8BAAR,GAAyCA,8BAAzC;;AAEA,SAASpB,gBAAT,CAA0BqB,IAA1B,EAAgC;EAC9B,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,IAAIF,IAAI,CAACG,QAAT,EAAmB,KAAKF,KAAL,CAAW,GAAX;EACnB,KAAKG,KAAL,CAAWJ,IAAI,CAACK,cAAhB,EAAgCL,IAAhC;AACD;;AAED,SAASf,4BAAT,CAAsCe,IAAtC,EAA4CM,MAA5C,EAAoD;EAClD,KAAKL,KAAL,CAAW,GAAX;EACA,KAAKM,SAAL,CAAeP,IAAI,CAACQ,MAApB,EAA4BR,IAA5B,EAAkC,EAAlC;;EAEA,IAAIM,MAAM,CAACG,IAAP,KAAgB,yBAAhB,IAA6CT,IAAI,CAACQ,MAAL,CAAYE,MAAZ,KAAuB,CAAxE,EAA2E;IACzE,KAAKT,KAAL,CAAW,GAAX;EACD;;EAED,KAAKA,KAAL,CAAW,GAAX;AACD;;AAED,SAASlB,eAAT,CAAyBiB,IAAzB,EAA+B;EAC7B,KAAKW,IAAL,CAAUX,IAAI,CAACY,IAAf;;EAEA,IAAIZ,IAAI,CAACa,UAAT,EAAqB;IACnB,KAAKX,KAAL;IACA,KAAKS,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;IACA,KAAKE,KAAL,CAAWJ,IAAI,CAACa,UAAhB,EAA4Bb,IAA5B;EACD;;EAED,IAAIA,IAAI,CAACc,OAAT,EAAkB;IAChB,KAAKZ,KAAL;IACA,KAAKD,KAAL,CAAW,GAAX;IACA,KAAKC,KAAL;IACA,KAAKE,KAAL,CAAWJ,IAAI,CAACc,OAAhB,EAAyBd,IAAzB;EACD;AACF;;AAED,SAAS/B,mBAAT,CAA6B+B,IAA7B,EAAmC;EACjC,IAAIA,IAAI,CAACe,aAAT,EAAwB;IACtB,KAAKJ,IAAL,CAAUX,IAAI,CAACe,aAAf;IACA,KAAKb,KAAL;EACD;;EAED,IAAIF,IAAI,CAACgB,QAAT,EAAmB;IACjB,KAAKL,IAAL,CAAU,UAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKe,MAAL,CAAYjB,IAAI,CAACkB,SAAjB;AACD;;AAED,SAAS/E,iBAAT,CAA2B6D,IAA3B,EAAiC;EAC/B,IAAIA,IAAI,CAACmB,OAAT,EAAkB;IAChB,KAAKR,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKkB,aAAL,CAAmBpB,IAAnB;;EAEA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAAS7D,eAAT,CAAyB4D,IAAzB,EAA+B;EAC7B,KAAKqB,gBAAL,CAAsBrB,IAAtB;;EAEA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAAS7B,eAAT,CAAyB4B,IAAzB,EAA+B;EAC7B,KAAKI,KAAL,CAAWJ,IAAI,CAACsB,IAAhB,EAAsBtB,IAAtB;EACA,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKG,KAAL,CAAWJ,IAAI,CAACuB,KAAhB,EAAuBvB,IAAvB;AACD;;AAED,SAASjE,0BAAT,CAAoCiE,IAApC,EAA0C;EACxC,KAAKH,+BAAL,CAAqCG,IAArC;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAAShE,+BAAT,CAAyC+D,IAAzC,EAA+C;EAC7C,KAAKW,IAAL,CAAU,KAAV;EACA,KAAKT,KAAL;EACA,KAAKL,+BAAL,CAAqCG,IAArC;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAAS9B,mBAAT,CAA6B6B,IAA7B,EAAmC;EACjC,MAAM;IACJgB,QADI;IAEJQ;EAFI,IAGFxB,IAHJ;;EAKA,IAAIgB,QAAJ,EAAc;IACZ,KAAKL,IAAL,CAAU,UAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKN,2BAAL,CAAiCI,IAAjC;EACA,KAAKI,KAAL,CAAWJ,IAAI,CAACK,cAAhB,EAAgCL,IAAhC;;EAEA,IAAIwB,WAAJ,EAAiB;IACf,KAAKtB,KAAL;IACA,KAAKD,KAAL,CAAW,GAAX;IACA,KAAKC,KAAL;IACA,KAAKE,KAAL,CAAWoB,WAAX,EAAwBxB,IAAxB;EACD;;EAED,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASL,2BAAT,CAAqCI,IAArC,EAA2C;EACzC,IAAIA,IAAI,CAACyB,QAAT,EAAmB;IACjB,KAAKxB,KAAL,CAAW,GAAX;EACD;;EAED,KAAKG,KAAL,CAAWJ,IAAI,CAAC0B,GAAhB,EAAqB1B,IAArB;;EAEA,IAAIA,IAAI,CAACyB,QAAT,EAAmB;IACjB,KAAKxB,KAAL,CAAW,GAAX;EACD;;EAED,IAAID,IAAI,CAACG,QAAT,EAAmB;IACjB,KAAKF,KAAL,CAAW,GAAX;EACD;AACF;;AAED,SAAS3C,iBAAT,CAA2B0C,IAA3B,EAAiC;EAC/B,MAAM;IACJ2B;EADI,IAEF3B,IAFJ;;EAIA,IAAI2B,IAAI,KAAK,KAAT,IAAkBA,IAAI,KAAK,KAA/B,EAAsC;IACpC,KAAKhB,IAAL,CAAUgB,IAAV;IACA,KAAKzB,KAAL;EACD;;EAED,KAAKN,2BAAL,CAAiCI,IAAjC;EACA,KAAKH,+BAAL,CAAqCG,IAArC;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASpD,gBAAT,CAA0BmD,IAA1B,EAAgC;EAC9B,MAAM;IACJgB,QADI;IAEJY,MAAM,EAAEC;EAFJ,IAGF7B,IAHJ;;EAKA,IAAI6B,QAAJ,EAAc;IACZ,KAAKlB,IAAL,CAAU,QAAV;IACA,KAAKT,KAAL;EACD;;EAED,IAAIc,QAAJ,EAAc;IACZ,KAAKL,IAAL,CAAU,UAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKD,KAAL,CAAW,GAAX;;EAEA,KAAK6B,WAAL,CAAiB9B,IAAI,CAAC+B,UAAtB,EAAkC/B,IAAlC;;EAEA,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKG,KAAL,CAAWJ,IAAI,CAACK,cAAhB,EAAgCL,IAAhC;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASvE,YAAT,GAAwB;EACtB,KAAKiF,IAAL,CAAU,KAAV;AACD;;AAED,SAAS9E,eAAT,GAA2B;EACzB,KAAK8E,IAAL,CAAU,QAAV;AACD;;AAED,SAASpB,gBAAT,GAA4B;EAC1B,KAAKoB,IAAL,CAAU,SAAV;AACD;;AAED,SAAS7C,eAAT,GAA2B;EACzB,KAAK6C,IAAL,CAAU,QAAV;AACD;;AAED,SAAS5C,eAAT,GAA2B;EACzB,KAAK4C,IAAL,CAAU,QAAV;AACD;;AAED,SAAS7E,gBAAT,GAA4B;EAC1B,KAAK6E,IAAL,CAAU,SAAV;AACD;;AAED,SAASrC,eAAT,GAA2B;EACzB,KAAKqC,IAAL,CAAU,QAAV;AACD;;AAED,SAASpC,eAAT,GAA2B;EACzB,KAAKoC,IAAL,CAAU,QAAV;AACD;;AAED,SAASnB,aAAT,GAAyB;EACvB,KAAKmB,IAAL,CAAU,MAAV;AACD;;AAED,SAAStB,kBAAT,GAA8B;EAC5B,KAAKsB,IAAL,CAAU,WAAV;AACD;;AAED,SAAS9C,aAAT,GAAyB;EACvB,KAAK8C,IAAL,CAAU,MAAV;AACD;;AAED,SAAShD,cAAT,GAA0B;EACxB,KAAKgD,IAAL,CAAU,OAAV;AACD;;AAED,SAASxD,kBAAT,GAA8B;EAC5B,KAAKwD,IAAL,CAAU,WAAV;AACD;;AAED,SAASnC,UAAT,GAAsB;EACpB,KAAKmC,IAAL,CAAU,MAAV;AACD;;AAED,SAASjE,cAAT,CAAwBsD,IAAxB,EAA8B;EAC5B,KAAKL,gCAAL,CAAsCK,IAAtC;AACD;;AAED,SAAS9D,iBAAT,CAA2B8D,IAA3B,EAAiC;EAC/B,IAAIA,IAAI,CAACgC,QAAT,EAAmB;IACjB,KAAKrB,IAAL,CAAU,UAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKS,IAAL,CAAU,KAAV;EACA,KAAKT,KAAL;EACA,KAAKP,gCAAL,CAAsCK,IAAtC;AACD;;AAED,SAASL,gCAAT,CAA0CK,IAA1C,EAAgD;EAC9C,MAAM;IACJiC;EADI,IAEFjC,IAFJ;EAGA,MAAM+B,UAAU,GAAG/B,IAAI,CAAC+B,UAAxB;EACA,KAAK3B,KAAL,CAAW6B,cAAX,EAA2BjC,IAA3B;EACA,KAAKC,KAAL,CAAW,GAAX;;EAEA,KAAK6B,WAAL,CAAiBC,UAAjB,EAA6B/B,IAA7B;;EAEA,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKD,KAAL,CAAW,IAAX;EACA,KAAKC,KAAL;EACA,MAAMgC,UAAU,GAAGlC,IAAI,CAACK,cAAxB;EACA,KAAKD,KAAL,CAAW8B,UAAU,CAAC7B,cAAtB,EAAsCL,IAAtC;AACD;;AAED,SAASZ,eAAT,CAAyBY,IAAzB,EAA+B;EAC7B,KAAKI,KAAL,CAAWJ,IAAI,CAACmC,QAAhB,EAA0BnC,IAA1B;EACA,KAAKI,KAAL,CAAWJ,IAAI,CAACiC,cAAhB,EAAgCjC,IAAhC;AACD;;AAED,SAASd,eAAT,CAAyBc,IAAzB,EAA+B;EAC7B,IAAIA,IAAI,CAACoC,OAAT,EAAkB;IAChB,KAAKzB,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKE,KAAL,CAAWJ,IAAI,CAACqC,aAAhB;;EAEA,IAAIrC,IAAI,CAACK,cAAT,EAAyB;IACvB,KAAKH,KAAL;IACA,KAAKS,IAAL,CAAU,IAAV;IACA,KAAKT,KAAL;IACA,KAAKE,KAAL,CAAWJ,IAAI,CAACK,cAAL,CAAoBA,cAA/B;EACD;AACF;;AAED,SAASlB,WAAT,CAAqBa,IAArB,EAA2B;EACzB,KAAKW,IAAL,CAAU,QAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACsC,QAAhB;AACD;;AAED,SAASzD,aAAT,CAAuBmB,IAAvB,EAA6B;EAC3B,KAAKF,iCAAL,CAAuCE,IAAI,CAACuC,OAA5C,EAAqDvC,IAArD;AACD;;AAED,SAASF,iCAAT,CAA2CyC,OAA3C,EAAoDvC,IAApD,EAA0D;EACxD,KAAKP,aAAL,CAAmB8C,OAAnB,EAA4BvC,IAA5B;AACD;;AAED,SAASP,aAAT,CAAuB8C,OAAvB,EAAgCvC,IAAhC,EAAsC;EACpC,KAAKC,KAAL,CAAW,GAAX;;EAEA,IAAIsC,OAAO,CAAC7B,MAAZ,EAAoB;IAClB,KAAK8B,MAAL;IACA,KAAKC,OAAL;;IAEA,KAAK,MAAMC,MAAX,IAAqBH,OAArB,EAA8B;MAC5B,KAAKnC,KAAL,CAAWsC,MAAX,EAAmB1C,IAAnB;MACA,KAAKyC,OAAL;IACD;;IAED,KAAKE,MAAL;IACA,KAAKC,UAAL;EACD,CAXD,MAWO;IACL,KAAK3C,KAAL,CAAW,GAAX;EACD;AACF;;AAED,SAAStE,WAAT,CAAqBqE,IAArB,EAA2B;EACzB,KAAKI,KAAL,CAAWJ,IAAI,CAAC6C,WAAhB,EAA6B7C,IAA7B;EACA,KAAKC,KAAL,CAAW,IAAX;AACD;;AAED,SAASxB,WAAT,CAAqBuB,IAArB,EAA2B;EACzB,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKM,SAAL,CAAeP,IAAI,CAAC8C,YAApB,EAAkC9C,IAAlC;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASjC,cAAT,CAAwBgC,IAAxB,EAA8B;EAC5B,KAAKI,KAAL,CAAWJ,IAAI,CAACK,cAAhB,EAAgCL,IAAhC;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAAS5B,UAAT,CAAoB2B,IAApB,EAA0B;EACxB,KAAKC,KAAL,CAAW,KAAX;EACA,KAAKG,KAAL,CAAWJ,IAAI,CAACK,cAAhB,EAAgCL,IAAhC;AACD;;AAED,SAASvC,kBAAT,CAA4BuC,IAA5B,EAAkC;EAChC,KAAKI,KAAL,CAAWJ,IAAI,CAAC+C,KAAhB,EAAuB/C,IAAvB;EACA,IAAIA,IAAI,CAACG,QAAT,EAAmB,KAAKF,KAAL,CAAW,GAAX;EACnB,KAAKA,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAAC6C,WAAhB,EAA6B7C,IAA7B;AACD;;AAED,SAASV,WAAT,CAAqBU,IAArB,EAA2B;EACzB,KAAKD,8BAAL,CAAoCC,IAApC,EAA0C,GAA1C;AACD;;AAED,SAAS9C,kBAAT,CAA4B8C,IAA5B,EAAkC;EAChC,KAAKD,8BAAL,CAAoCC,IAApC,EAA0C,GAA1C;AACD;;AAED,SAASD,8BAAT,CAAwCC,IAAxC,EAA8CgD,GAA9C,EAAmD;EACjD,KAAKC,SAAL,CAAejD,IAAI,CAACkD,KAApB,EAA2BlD,IAA3B,EAAiC;IAC/BmD,SAAS,GAAG;MACV,KAAKjD,KAAL;MACA,KAAKD,KAAL,CAAW+C,GAAX;MACA,KAAK9C,KAAL;IACD;;EAL8B,CAAjC;AAQD;;AAED,SAASlE,iBAAT,CAA2BgE,IAA3B,EAAiC;EAC/B,KAAKI,KAAL,CAAWJ,IAAI,CAACoD,SAAhB;EACA,KAAKlD,KAAL;EACA,KAAKS,IAAL,CAAU,SAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACqD,WAAhB;EACA,KAAKnD,KAAL;EACA,KAAKD,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACsD,QAAhB;EACA,KAAKpD,KAAL;EACA,KAAKD,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACuD,SAAhB;AACD;;AAED,SAASxG,WAAT,CAAqBiD,IAArB,EAA2B;EACzB,KAAKC,KAAL,CAAW,OAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACwD,aAAhB;AACD;;AAED,SAAStF,mBAAT,CAA6B8B,IAA7B,EAAmC;EACjC,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKG,KAAL,CAAWJ,IAAI,CAACK,cAAhB,EAAgCL,IAAhC;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASnB,cAAT,CAAwBkB,IAAxB,EAA8B;EAC5B,KAAKW,IAAL,CAAUX,IAAI,CAACyD,QAAf;EACA,KAAKvD,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACK,cAAhB,EAAgCL,IAAhC;AACD;;AAED,SAASlD,mBAAT,CAA6BkD,IAA7B,EAAmC;EACjC,KAAKI,KAAL,CAAWJ,IAAI,CAAC0D,UAAhB,EAA4B1D,IAA5B;EACA,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKG,KAAL,CAAWJ,IAAI,CAAC2D,SAAhB,EAA2B3D,IAA3B;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAAS5C,YAAT,CAAsB2C,IAAtB,EAA4B;EAC1B,MAAM;IACJ4D,QADI;IAEJzD,QAFI;IAGJa,QAHI;IAIJwC;EAJI,IAKFxD,IALJ;EAMA,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;;EAEA,IAAIc,QAAJ,EAAc;IACZ6C,gBAAgB,CAAC,IAAD,EAAO7C,QAAP,CAAhB;IACA,KAAKL,IAAL,CAAU,UAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKD,KAAL,CAAW,GAAX;EACA,KAAKU,IAAL,CAAU6C,aAAa,CAAC5C,IAAxB;EACA,KAAKV,KAAL;EACA,KAAKS,IAAL,CAAU,IAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAWoD,aAAa,CAAC3C,UAAzB,EAAqC2C,aAArC;;EAEA,IAAII,QAAJ,EAAc;IACZ,KAAK1D,KAAL;IACA,KAAKS,IAAL,CAAU,IAAV;IACA,KAAKT,KAAL;IACA,KAAKE,KAAL,CAAWwD,QAAX,EAAqB5D,IAArB;EACD;;EAED,KAAKC,KAAL,CAAW,GAAX;;EAEA,IAAIE,QAAJ,EAAc;IACZ0D,gBAAgB,CAAC,IAAD,EAAO1D,QAAP,CAAhB;IACA,KAAKF,KAAL,CAAW,GAAX;EACD;;EAED,KAAKA,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACK,cAAhB,EAAgCL,IAAhC;EACA,KAAKE,KAAL;EACA,KAAKD,KAAL,CAAW,GAAX;AACD;;AAED,SAAS4D,gBAAT,CAA0BC,IAA1B,EAAgCC,GAAhC,EAAqC;EACnC,IAAIA,GAAG,KAAK,IAAZ,EAAkB;IAChBD,IAAI,CAAC7D,KAAL,CAAW8D,GAAX;EACD;AACF;;AAED,SAAS3G,aAAT,CAAuB4C,IAAvB,EAA6B;EAC3B,KAAKI,KAAL,CAAWJ,IAAI,CAACgE,OAAhB,EAAyBhE,IAAzB;AACD;;AAED,SAASxD,6BAAT,CAAuCwD,IAAvC,EAA6C;EAC3C,KAAKI,KAAL,CAAWJ,IAAI,CAACiE,UAAhB,EAA4BjE,IAA5B;EACA,KAAKI,KAAL,CAAWJ,IAAI,CAACiC,cAAhB,EAAgCjC,IAAhC;AACD;;AAED,SAAS/C,sBAAT,CAAgC+C,IAAhC,EAAsC;EACpC,MAAM;IACJmB,OADI;IAEJ+C,EAFI;IAGJjC,cAHI;IAIJkC,OAAO,EAAEC,OAJL;IAKJC;EALI,IAMFrE,IANJ;;EAQA,IAAImB,OAAJ,EAAa;IACX,KAAKR,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKS,IAAL,CAAU,WAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAW8D,EAAX,EAAelE,IAAf;EACA,KAAKI,KAAL,CAAW6B,cAAX,EAA2BjC,IAA3B;;EAEA,IAAIoE,OAAO,IAAI,IAAX,IAAmBA,OAAO,CAAC1D,MAA/B,EAAuC;IACrC,KAAKR,KAAL;IACA,KAAKS,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;IACA,KAAKK,SAAL,CAAe6D,OAAf,EAAwBpE,IAAxB;EACD;;EAED,KAAKE,KAAL;EACA,KAAKE,KAAL,CAAWiE,IAAX,EAAiBrE,IAAjB;AACD;;AAED,SAAShD,eAAT,CAAyBgD,IAAzB,EAA+B;EAC7B,KAAKF,iCAAL,CAAuCE,IAAI,CAACqE,IAA5C,EAAkDrE,IAAlD;AACD;;AAED,SAAStB,sBAAT,CAAgCsB,IAAhC,EAAsC;EACpC,MAAM;IACJmB,OADI;IAEJ+C,EAFI;IAGJjC,cAHI;IAIJ5B;EAJI,IAKFL,IALJ;;EAOA,IAAImB,OAAJ,EAAa;IACX,KAAKR,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKS,IAAL,CAAU,MAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAW8D,EAAX,EAAelE,IAAf;EACA,KAAKI,KAAL,CAAW6B,cAAX,EAA2BjC,IAA3B;EACA,KAAKE,KAAL;EACA,KAAKD,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAWC,cAAX,EAA2BL,IAA3B;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASrE,cAAT,CAAwBoE,IAAxB,EAA8B;EAC5B,MAAM;IACJiE,UADI;IAEJ5D;EAFI,IAGFL,IAHJ;EAIA,KAAKI,KAAL,CAAW6D,UAAX,EAAuBjE,IAAvB;EACA,KAAKE,KAAL;EACA,KAAKS,IAAL,CAAU,IAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAWC,cAAX,EAA2BL,IAA3B;AACD;;AAED,SAASpB,eAAT,CAAyBoB,IAAzB,EAA+B;EAC7B,MAAM;IACJK,cADI;IAEJ4D;EAFI,IAGFjE,IAHJ;EAIA,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKG,KAAL,CAAWC,cAAX,EAA2BL,IAA3B;EACA,KAAKC,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAW6D,UAAX,EAAuBjE,IAAvB;AACD;;AAED,SAAS3D,iBAAT,CAA2B2D,IAA3B,EAAiC;EAC/B,MAAM;IACJmB,OADI;IAEJmD,KAAK,EAAEC,OAFH;IAGJL,EAHI;IAIJ3B;EAJI,IAKFvC,IALJ;;EAOA,IAAImB,OAAJ,EAAa;IACX,KAAKR,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;EACD;;EAED,IAAIqE,OAAJ,EAAa;IACX,KAAK5D,IAAL,CAAU,OAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKS,IAAL,CAAU,MAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAW8D,EAAX,EAAelE,IAAf;EACA,KAAKE,KAAL;EACA,KAAKT,aAAL,CAAmB8C,OAAnB,EAA4BvC,IAA5B;AACD;;AAED,SAAS1D,YAAT,CAAsB0D,IAAtB,EAA4B;EAC1B,MAAM;IACJkE,EADI;IAEJ1C;EAFI,IAGFxB,IAHJ;EAIA,KAAKI,KAAL,CAAW8D,EAAX,EAAelE,IAAf;;EAEA,IAAIwB,WAAJ,EAAiB;IACf,KAAKtB,KAAL;IACA,KAAKD,KAAL,CAAW,GAAX;IACA,KAAKC,KAAL;IACA,KAAKE,KAAL,CAAWoB,WAAX,EAAwBxB,IAAxB;EACD;;EAED,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASzC,mBAAT,CAA6BwC,IAA7B,EAAmC;EACjC,MAAM;IACJmB,OADI;IAEJ+C;EAFI,IAGFlE,IAHJ;;EAKA,IAAImB,OAAJ,EAAa;IACX,KAAKR,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;EACD;;EAED,IAAI,CAACF,IAAI,CAACwE,MAAV,EAAkB;IAChB,KAAK7D,IAAL,CAAUuD,EAAE,CAACzD,IAAH,KAAY,YAAZ,GAA2B,WAA3B,GAAyC,QAAnD;IACA,KAAKP,KAAL;EACD;;EAED,KAAKE,KAAL,CAAW8D,EAAX,EAAelE,IAAf;;EAEA,IAAI,CAACA,IAAI,CAACqE,IAAV,EAAgB;IACd,KAAKpE,KAAL,CAAW,GAAX;IACA;EACD;;EAED,IAAIoE,IAAI,GAAGrE,IAAI,CAACqE,IAAhB;;EAEA,OAAOA,IAAI,CAAC5D,IAAL,KAAc,qBAArB,EAA4C;IAC1C,KAAKR,KAAL,CAAW,GAAX;IACA,KAAKG,KAAL,CAAWiE,IAAI,CAACH,EAAhB,EAAoBG,IAApB;IACAA,IAAI,GAAGA,IAAI,CAACA,IAAZ;EACD;;EAED,KAAKnE,KAAL;EACA,KAAKE,KAAL,CAAWiE,IAAX,EAAiBrE,IAAjB;AACD;;AAED,SAASzC,aAAT,CAAuByC,IAAvB,EAA6B;EAC3B,KAAKP,aAAL,CAAmBO,IAAI,CAACqE,IAAxB,EAA8BrE,IAA9B;AACD;;AAED,SAASpD,YAAT,CAAsBoD,IAAtB,EAA4B;EAC1B,MAAM;IACJyE,QADI;IAEJC,SAFI;IAGJzC;EAHI,IAIFjC,IAJJ;EAKA,KAAKW,IAAL,CAAU,QAAV;EACA,KAAKV,KAAL,CAAW,GAAX;EACA,KAAKG,KAAL,CAAWqE,QAAX,EAAqBzE,IAArB;EACA,KAAKC,KAAL,CAAW,GAAX;;EAEA,IAAIyE,SAAJ,EAAe;IACb,KAAKzE,KAAL,CAAW,GAAX;IACA,KAAKG,KAAL,CAAWsE,SAAX,EAAsB1E,IAAtB;EACD;;EAED,IAAIiC,cAAJ,EAAoB;IAClB,KAAK7B,KAAL,CAAW6B,cAAX,EAA2BjC,IAA3B;EACD;AACF;;AAED,SAASrD,yBAAT,CAAmCqD,IAAnC,EAAyC;EACvC,MAAM;IACJ2E,QADI;IAEJT,EAFI;IAGJU;EAHI,IAIF5E,IAJJ;;EAMA,IAAI2E,QAAJ,EAAc;IACZ,KAAKhE,IAAL,CAAU,QAAV;IACA,KAAKT,KAAL;EACD;;EAED,KAAKS,IAAL,CAAU,QAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAW8D,EAAX,EAAelE,IAAf;EACA,KAAKE,KAAL;EACA,KAAKD,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAWwE,eAAX,EAA4B5E,IAA5B;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASxD,yBAAT,CAAmCuD,IAAnC,EAAyC;EACvC,KAAKC,KAAL,CAAW,UAAX;EACA,KAAKG,KAAL,CAAWJ,IAAI,CAACiE,UAAhB,EAA4BjE,IAA5B;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASrC,mBAAT,CAA6BoC,IAA7B,EAAmC;EACjC,KAAKI,KAAL,CAAWJ,IAAI,CAACiE,UAAhB,EAA4BjE,IAA5B;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAAS1D,kBAAT,CAA4ByD,IAA5B,EAAkC;EAChC,KAAKW,IAAL,CAAU,QAAV;EACA,KAAKT,KAAL;EACA,KAAKD,KAAL,CAAW,GAAX;EACA,KAAKC,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACiE,UAAhB,EAA4BjE,IAA5B;EACA,KAAKC,KAAL,CAAW,GAAX;AACD;;AAED,SAASvC,4BAAT,CAAsCsC,IAAtC,EAA4C;EAC1C,KAAKW,IAAL,CAAU,QAAV;EACA,KAAKT,KAAL;EACA,KAAKS,IAAL,CAAU,IAAV;EACA,KAAKT,KAAL;EACA,KAAKS,IAAL,CAAU,WAAV;EACA,KAAKT,KAAL;EACA,KAAKE,KAAL,CAAWJ,IAAI,CAACkE,EAAhB,EAAoBlE,IAApB;AACD;;AAED,SAASH,+BAAT,CAAyCG,IAAzC,EAA+C;EAC7C,MAAM;IACJiC;EADI,IAEFjC,IAFJ;EAGA,MAAM+B,UAAU,GAAG/B,IAAI,CAAC+B,UAAxB;EACA,KAAK3B,KAAL,CAAW6B,cAAX,EAA2BjC,IAA3B;EACA,KAAKC,KAAL,CAAW,GAAX;;EAEA,KAAK6B,WAAL,CAAiBC,UAAjB,EAA6B/B,IAA7B;;EAEA,KAAKC,KAAL,CAAW,GAAX;EACA,MAAMiC,UAAU,GAAGlC,IAAI,CAACK,cAAxB;EACA,KAAKD,KAAL,CAAW8B,UAAX,EAAuBlC,IAAvB;AACD;;AAED,SAASN,2BAAT,CAAqCM,IAArC,EAA2C6E,OAA3C,EAAoD;EAClD,IAAIA,OAAO,IAAI7E,IAAI,CAACmB,OAApB,EAA6B;IAC3B,KAAKR,IAAL,CAAU,SAAV;IACA,KAAKT,KAAL;EACD;;EAED,IAAIF,IAAI,CAACe,aAAT,EAAwB;IACtB,KAAKJ,IAAL,CAAUX,IAAI,CAACe,aAAf;IACA,KAAKb,KAAL;EACD;;EAED,IAAIF,IAAI,CAAC4B,MAAT,EAAiB;IACf,KAAKjB,IAAL,CAAU,QAAV;IACA,KAAKT,KAAL;EACD;;EAED,IAAIF,IAAI,CAAC8E,QAAT,EAAmB;IACjB,KAAKnE,IAAL,CAAU,UAAV;IACA,KAAKT,KAAL;EACD;;EAED,IAAIF,IAAI,CAACgC,QAAT,EAAmB;IACjB,KAAKrB,IAAL,CAAU,UAAV;IACA,KAAKT,KAAL;EACD;;EAED,IAAI2E,OAAO,IAAI7E,IAAI,CAACgB,QAApB,EAA8B;IAC5B,KAAKL,IAAL,CAAU,UAAV;IACA,KAAKT,KAAL;EACD;AACF"},"metadata":{},"sourceType":"script"}