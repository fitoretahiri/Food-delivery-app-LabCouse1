{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeModuleAndLoadMetadata;\nexports.hasExports = hasExports;\nexports.isSideEffectImport = isSideEffectImport;\nexports.validateImportInteropOption = validateImportInteropOption;\n\nvar _path = require(\"path\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nfunction hasExports(metadata) {\n  return metadata.hasExports;\n}\n\nfunction isSideEffectImport(source) {\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\n}\n\nfunction validateImportInteropOption(importInterop) {\n  if (typeof importInterop !== \"function\" && importInterop !== \"none\" && importInterop !== \"babel\" && importInterop !== \"node\") {\n    throw new Error(`.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`);\n  }\n\n  return importInterop;\n}\n\nfunction resolveImportInterop(importInterop, source) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source));\n  }\n\n  return importInterop;\n}\n\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, _ref) {\n  let {\n    importInterop,\n    initializeReexports = false,\n    lazy = false,\n    esNamespaceOnly = false\n  } = _ref;\n\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n\n  const stringSpecifiers = new Set();\n  nameAnonymousExports(programPath);\n  const {\n    local,\n    source,\n    hasExports\n  } = getModuleMetadata(programPath, {\n    initializeReexports,\n    lazy\n  }, stringSpecifiers);\n  removeModuleDeclarations(programPath);\n\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n\n    const resolvedInterop = resolveImportInterop(importInterop, metadata.source);\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source,\n    stringSpecifiers\n  };\n}\n\nfunction getExportSpecifierName(path, stringSpecifiers) {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);\n  }\n}\n\nfunction assertExportSpecifier(path) {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\");\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\nfunction getModuleMetadata(programPath, _ref2, stringSpecifiers) {\n  let {\n    lazy,\n    initializeReexports\n  } = _ref2;\n  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);\n  const sourceData = new Map();\n\n  const getData = sourceNode => {\n    const source = sourceNode.value;\n    let data = sourceData.get(source);\n\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\n        interop: \"none\",\n        loc: null,\n        imports: new Map(),\n        importsNamespace: new Set(),\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n        lazy: false,\n        source\n      };\n      sourceData.set(source, data);\n    }\n\n    return data;\n  };\n\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, \"default\");\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(spec.get(\"imported\"), stringSpecifiers);\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, importName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      data.reexportAll = {\n        loc: child.node.loc\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(spec.get(\"local\"), stringSpecifiers);\n        const exportName = getExportSpecifierName(spec.get(\"exported\"), stringSpecifiers);\n        data.reexports.set(exportName, importName);\n\n        if (exportName === \"__esModule\") {\n          throw spec.get(\"exported\").buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  for (const [source, metadata] of sourceData) {\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\n      if (lazy === true) {\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData\n  };\n}\n\nfunction getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {\n  const bindingKindLookup = new Map();\n  programPath.get(\"body\").forEach(child => {\n    let kind;\n\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) child = child.get(\"declaration\");\n\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (initializeReexports && child.node.source && child.get(\"source\").isStringLiteral()) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({\n        kind: \"var\"\n      })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n  const localMetadata = new Map();\n\n  const getLocalMetadata = idPath => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\n      }\n\n      metadata = {\n        names: [],\n        kind\n      };\n      localMetadata.set(localName, metadata);\n    }\n\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    }\n  });\n  return localMetadata;\n}\n\nfunction nameAnonymousExports(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    (0, _helperSplitExportDeclaration.default)(child);\n  });\n}\n\nfunction removeModuleDeclarations(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","normalizeModuleAndLoadMetadata","hasExports","isSideEffectImport","validateImportInteropOption","_path","require","_helperValidatorIdentifier","_helperSplitExportDeclaration","metadata","source","imports","size","importsNamespace","reexports","reexportNamespace","reexportAll","importInterop","Error","resolveImportInterop","programPath","exportName","initializeReexports","lazy","esNamespaceOnly","scope","generateUidIdentifier","name","stringSpecifiers","Set","nameAnonymousExports","local","getModuleMetadata","removeModuleDeclarations","values","next","resolvedInterop","interop","exportNameListName","getExportSpecifierName","path","isIdentifier","node","isStringLiteral","stringValue","isIdentifierName","add","type","assertExportSpecifier","isExportSpecifier","isExportNamespaceSpecifier","buildCodeFrameError","localData","getLocalExportMetadata","sourceData","Map","getData","sourceNode","data","get","basename","extname","loc","set","forEach","child","isImportDeclaration","spec","isImportDefaultSpecifier","localName","reexport","delete","names","isImportNamespaceSpecifier","isImportSpecifier","importName","isExportAllDeclaration","isExportNamedDeclaration","isExportDefaultDeclaration","needsDefault","needsNamed","test","Array","isArray","indexOf","bindingKindLookup","kind","declaration","isFunctionDeclaration","isClassDeclaration","isVariableDeclaration","keys","getOuterBindingIdentifiers","localMetadata","getLocalMetadata","idPath","undefined","ids","getOuterBindingIdentifierPaths","push","exported","remove","_blockHoist","replaceWith"],"sources":["C:/Users/Arber/Documents/GitHub/Food-delivery-app-LabCouse1/Food-delivery-app-LabCouse1/front-end-code/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = normalizeModuleAndLoadMetadata;\r\nexports.hasExports = hasExports;\r\nexports.isSideEffectImport = isSideEffectImport;\r\nexports.validateImportInteropOption = validateImportInteropOption;\r\n\r\nvar _path = require(\"path\");\r\n\r\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\r\n\r\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\r\n\r\nfunction hasExports(metadata) {\r\n  return metadata.hasExports;\r\n}\r\n\r\nfunction isSideEffectImport(source) {\r\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\r\n}\r\n\r\nfunction validateImportInteropOption(importInterop) {\r\n  if (typeof importInterop !== \"function\" && importInterop !== \"none\" && importInterop !== \"babel\" && importInterop !== \"node\") {\r\n    throw new Error(`.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`);\r\n  }\r\n\r\n  return importInterop;\r\n}\r\n\r\nfunction resolveImportInterop(importInterop, source) {\r\n  if (typeof importInterop === \"function\") {\r\n    return validateImportInteropOption(importInterop(source));\r\n  }\r\n\r\n  return importInterop;\r\n}\r\n\r\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, {\r\n  importInterop,\r\n  initializeReexports = false,\r\n  lazy = false,\r\n  esNamespaceOnly = false\r\n}) {\r\n  if (!exportName) {\r\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\r\n  }\r\n\r\n  const stringSpecifiers = new Set();\r\n  nameAnonymousExports(programPath);\r\n  const {\r\n    local,\r\n    source,\r\n    hasExports\r\n  } = getModuleMetadata(programPath, {\r\n    initializeReexports,\r\n    lazy\r\n  }, stringSpecifiers);\r\n  removeModuleDeclarations(programPath);\r\n\r\n  for (const [, metadata] of source) {\r\n    if (metadata.importsNamespace.size > 0) {\r\n      metadata.name = metadata.importsNamespace.values().next().value;\r\n    }\r\n\r\n    const resolvedInterop = resolveImportInterop(importInterop, metadata.source);\r\n\r\n    if (resolvedInterop === \"none\") {\r\n      metadata.interop = \"none\";\r\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\r\n      metadata.interop = \"node-namespace\";\r\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\r\n      metadata.interop = \"node-default\";\r\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\r\n      metadata.interop = \"default\";\r\n    }\r\n  }\r\n\r\n  return {\r\n    exportName,\r\n    exportNameListName: null,\r\n    hasExports,\r\n    local,\r\n    source,\r\n    stringSpecifiers\r\n  };\r\n}\r\n\r\nfunction getExportSpecifierName(path, stringSpecifiers) {\r\n  if (path.isIdentifier()) {\r\n    return path.node.name;\r\n  } else if (path.isStringLiteral()) {\r\n    const stringValue = path.node.value;\r\n\r\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\r\n      stringSpecifiers.add(stringValue);\r\n    }\r\n\r\n    return stringValue;\r\n  } else {\r\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);\r\n  }\r\n}\r\n\r\nfunction assertExportSpecifier(path) {\r\n  if (path.isExportSpecifier()) {\r\n    return;\r\n  } else if (path.isExportNamespaceSpecifier()) {\r\n    throw path.buildCodeFrameError(\"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\");\r\n  } else {\r\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\r\n  }\r\n}\r\n\r\nfunction getModuleMetadata(programPath, {\r\n  lazy,\r\n  initializeReexports\r\n}, stringSpecifiers) {\r\n  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);\r\n  const sourceData = new Map();\r\n\r\n  const getData = sourceNode => {\r\n    const source = sourceNode.value;\r\n    let data = sourceData.get(source);\r\n\r\n    if (!data) {\r\n      data = {\r\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\r\n        interop: \"none\",\r\n        loc: null,\r\n        imports: new Map(),\r\n        importsNamespace: new Set(),\r\n        reexports: new Map(),\r\n        reexportNamespace: new Set(),\r\n        reexportAll: null,\r\n        lazy: false,\r\n        source\r\n      };\r\n      sourceData.set(source, data);\r\n    }\r\n\r\n    return data;\r\n  };\r\n\r\n  let hasExports = false;\r\n  programPath.get(\"body\").forEach(child => {\r\n    if (child.isImportDeclaration()) {\r\n      const data = getData(child.node.source);\r\n      if (!data.loc) data.loc = child.node.loc;\r\n      child.get(\"specifiers\").forEach(spec => {\r\n        if (spec.isImportDefaultSpecifier()) {\r\n          const localName = spec.get(\"local\").node.name;\r\n          data.imports.set(localName, \"default\");\r\n          const reexport = localData.get(localName);\r\n\r\n          if (reexport) {\r\n            localData.delete(localName);\r\n            reexport.names.forEach(name => {\r\n              data.reexports.set(name, \"default\");\r\n            });\r\n          }\r\n        } else if (spec.isImportNamespaceSpecifier()) {\r\n          const localName = spec.get(\"local\").node.name;\r\n          data.importsNamespace.add(localName);\r\n          const reexport = localData.get(localName);\r\n\r\n          if (reexport) {\r\n            localData.delete(localName);\r\n            reexport.names.forEach(name => {\r\n              data.reexportNamespace.add(name);\r\n            });\r\n          }\r\n        } else if (spec.isImportSpecifier()) {\r\n          const importName = getExportSpecifierName(spec.get(\"imported\"), stringSpecifiers);\r\n          const localName = spec.get(\"local\").node.name;\r\n          data.imports.set(localName, importName);\r\n          const reexport = localData.get(localName);\r\n\r\n          if (reexport) {\r\n            localData.delete(localName);\r\n            reexport.names.forEach(name => {\r\n              data.reexports.set(name, importName);\r\n            });\r\n          }\r\n        }\r\n      });\r\n    } else if (child.isExportAllDeclaration()) {\r\n      hasExports = true;\r\n      const data = getData(child.node.source);\r\n      if (!data.loc) data.loc = child.node.loc;\r\n      data.reexportAll = {\r\n        loc: child.node.loc\r\n      };\r\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\r\n      hasExports = true;\r\n      const data = getData(child.node.source);\r\n      if (!data.loc) data.loc = child.node.loc;\r\n      child.get(\"specifiers\").forEach(spec => {\r\n        assertExportSpecifier(spec);\r\n        const importName = getExportSpecifierName(spec.get(\"local\"), stringSpecifiers);\r\n        const exportName = getExportSpecifierName(spec.get(\"exported\"), stringSpecifiers);\r\n        data.reexports.set(exportName, importName);\r\n\r\n        if (exportName === \"__esModule\") {\r\n          throw spec.get(\"exported\").buildCodeFrameError('Illegal export \"__esModule\".');\r\n        }\r\n      });\r\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\r\n      hasExports = true;\r\n    }\r\n  });\r\n\r\n  for (const metadata of sourceData.values()) {\r\n    let needsDefault = false;\r\n    let needsNamed = false;\r\n\r\n    if (metadata.importsNamespace.size > 0) {\r\n      needsDefault = true;\r\n      needsNamed = true;\r\n    }\r\n\r\n    if (metadata.reexportAll) {\r\n      needsNamed = true;\r\n    }\r\n\r\n    for (const importName of metadata.imports.values()) {\r\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\r\n    }\r\n\r\n    for (const importName of metadata.reexports.values()) {\r\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\r\n    }\r\n\r\n    if (needsDefault && needsNamed) {\r\n      metadata.interop = \"namespace\";\r\n    } else if (needsDefault) {\r\n      metadata.interop = \"default\";\r\n    }\r\n  }\r\n\r\n  for (const [source, metadata] of sourceData) {\r\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\r\n      if (lazy === true) {\r\n        metadata.lazy = !/\\./.test(source);\r\n      } else if (Array.isArray(lazy)) {\r\n        metadata.lazy = lazy.indexOf(source) !== -1;\r\n      } else if (typeof lazy === \"function\") {\r\n        metadata.lazy = lazy(source);\r\n      } else {\r\n        throw new Error(`.lazy must be a boolean, string array, or function`);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    hasExports,\r\n    local: localData,\r\n    source: sourceData\r\n  };\r\n}\r\n\r\nfunction getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {\r\n  const bindingKindLookup = new Map();\r\n  programPath.get(\"body\").forEach(child => {\r\n    let kind;\r\n\r\n    if (child.isImportDeclaration()) {\r\n      kind = \"import\";\r\n    } else {\r\n      if (child.isExportDefaultDeclaration()) child = child.get(\"declaration\");\r\n\r\n      if (child.isExportNamedDeclaration()) {\r\n        if (child.node.declaration) {\r\n          child = child.get(\"declaration\");\r\n        } else if (initializeReexports && child.node.source && child.get(\"source\").isStringLiteral()) {\r\n          child.get(\"specifiers\").forEach(spec => {\r\n            assertExportSpecifier(spec);\r\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (child.isFunctionDeclaration()) {\r\n        kind = \"hoisted\";\r\n      } else if (child.isClassDeclaration()) {\r\n        kind = \"block\";\r\n      } else if (child.isVariableDeclaration({\r\n        kind: \"var\"\r\n      })) {\r\n        kind = \"var\";\r\n      } else if (child.isVariableDeclaration()) {\r\n        kind = \"block\";\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n\r\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\r\n      bindingKindLookup.set(name, kind);\r\n    });\r\n  });\r\n  const localMetadata = new Map();\r\n\r\n  const getLocalMetadata = idPath => {\r\n    const localName = idPath.node.name;\r\n    let metadata = localMetadata.get(localName);\r\n\r\n    if (!metadata) {\r\n      const kind = bindingKindLookup.get(localName);\r\n\r\n      if (kind === undefined) {\r\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\r\n      }\r\n\r\n      metadata = {\r\n        names: [],\r\n        kind\r\n      };\r\n      localMetadata.set(localName, metadata);\r\n    }\r\n\r\n    return metadata;\r\n  };\r\n\r\n  programPath.get(\"body\").forEach(child => {\r\n    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {\r\n      if (child.node.declaration) {\r\n        const declaration = child.get(\"declaration\");\r\n        const ids = declaration.getOuterBindingIdentifierPaths();\r\n        Object.keys(ids).forEach(name => {\r\n          if (name === \"__esModule\") {\r\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\r\n          }\r\n\r\n          getLocalMetadata(ids[name]).names.push(name);\r\n        });\r\n      } else {\r\n        child.get(\"specifiers\").forEach(spec => {\r\n          const local = spec.get(\"local\");\r\n          const exported = spec.get(\"exported\");\r\n          const localMetadata = getLocalMetadata(local);\r\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\r\n\r\n          if (exportName === \"__esModule\") {\r\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\r\n          }\r\n\r\n          localMetadata.names.push(exportName);\r\n        });\r\n      }\r\n    } else if (child.isExportDefaultDeclaration()) {\r\n      const declaration = child.get(\"declaration\");\r\n\r\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\r\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\r\n      } else {\r\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\r\n      }\r\n    }\r\n  });\r\n  return localMetadata;\r\n}\r\n\r\nfunction nameAnonymousExports(programPath) {\r\n  programPath.get(\"body\").forEach(child => {\r\n    if (!child.isExportDefaultDeclaration()) return;\r\n    (0, _helperSplitExportDeclaration.default)(child);\r\n  });\r\n}\r\n\r\nfunction removeModuleDeclarations(programPath) {\r\n  programPath.get(\"body\").forEach(child => {\r\n    if (child.isImportDeclaration()) {\r\n      child.remove();\r\n    } else if (child.isExportNamedDeclaration()) {\r\n      if (child.node.declaration) {\r\n        child.node.declaration._blockHoist = child.node._blockHoist;\r\n        child.replaceWith(child.node.declaration);\r\n      } else {\r\n        child.remove();\r\n      }\r\n    } else if (child.isExportDefaultDeclaration()) {\r\n      const declaration = child.get(\"declaration\");\r\n\r\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\r\n        declaration._blockHoist = child.node._blockHoist;\r\n        child.replaceWith(declaration);\r\n      } else {\r\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\r\n      }\r\n    } else if (child.isExportAllDeclaration()) {\r\n      child.remove();\r\n    }\r\n  });\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}