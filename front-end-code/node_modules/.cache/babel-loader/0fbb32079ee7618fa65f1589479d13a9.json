{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nexports.wrapInterop = wrapInterop;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _rewriteThis = require(\"./rewrite-this\");\n\nvar _rewriteLiveReferences = require(\"./rewrite-live-references\");\n\nvar _normalizeAndLoadMetadata = require(\"./normalize-and-load-metadata\");\n\nvar _getModuleName = require(\"./get-module-name\");\n\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction rewriteModuleStatementsAndPrepareHeader(path, _ref) {\n  let {\n    loose,\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    lazy,\n    esNamespaceOnly,\n    constantReexports = loose,\n    enumerableModuleMeta = loose,\n    noIncompleteNsImportDetection\n  } = _ref;\n  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);\n\n  _assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly\n  });\n\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n\n  (0, _rewriteLiveReferences.default)(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", directive(directiveLiteral(\"use strict\")));\n    }\n  }\n\n  const headers = [];\n\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));\n  return {\n    meta,\n    headers\n  };\n}\n\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\n\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [expr, booleanLiteral(true)]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\nfunction buildNamespaceInitStatements(metadata, sourceMetadata) {\n  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const statements = [];\n  let srcNamespace = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: _template.default.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\n\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\n  const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, _ref2 => {\n    let [exportName, importName] = _ref2;\n    let NAMESPACE_IMPORT = cloneNode(namespace);\n\n    if (importName === \"default\" && metadata.interop === \"node-default\") {} else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));\n    }\n\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\nfunction buildESModuleHeader(metadata) {\n  let enumerableModuleMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\n\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\n\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [variableDeclarator(name, valueToNode(exportedVars))])\n  };\n}\n\nfunction buildExportInitializationStatements(programPath, metadata) {\n  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let noIncompleteNsImportDetection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const initStatements = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  initStatements.sort((_ref3, _ref4) => {\n    let [a] = _ref3;\n    let [b] = _ref4;\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n  const results = [];\n\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    const chunkSize = 100;\n\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n            uninitializedExportNames = [];\n          }\n\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n\n      if (uninitializedExportNames.length > 0) {\n        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n      }\n    }\n  }\n\n  return results;\n}\n\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\n\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","buildNamespaceInitStatements","ensureStatementsHoisted","enumerable","get","_getModuleName","default","_normalizeAndLoadMetadata","hasExports","_helperModuleImports","isModule","isSideEffectImport","rewriteModuleStatementsAndPrepareHeader","_rewriteThis","wrapInterop","_assert","require","_t","_template","_rewriteLiveReferences","booleanLiteral","callExpression","cloneNode","directive","directiveLiteral","expressionStatement","identifier","isIdentifier","memberExpression","stringLiteral","valueToNode","variableDeclaration","variableDeclarator","path","loose","exportName","strict","allowTopLevelThis","strictMode","noInterop","importInterop","lazy","esNamespaceOnly","constantReexports","enumerableModuleMeta","noIncompleteNsImportDetection","validateImportInteropOption","node","sourceType","meta","initializeReexports","hasStrict","directives","some","unshiftContainer","headers","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","buildExportInitializationStatements","statements","forEach","header","_blockHoist","programPath","expr","type","hub","addHelper","helper","Error","metadata","sourceMetadata","srcNamespace","localName","importsNamespace","NAME","SOURCE","buildReexportsFromMeta","reexportNamespace","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","constantComputed","spec","namespace","stringSpecifiers","Array","from","reexports","importName","NAMESPACE_IMPORT","interop","has","astNodes","EXPORT_NAME","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","create","data","local","values","names","hasReexport","source","keys","length","scope","generateUidIdentifier","initStatements","kind","buildInitStatement","reexportsStatements","i","sort","a","b","results","initStatement","chunkSize","uninitializedExportNames","j","buildUndefinedNode","InitTemplate","computed","expression","exportNames","initExpr","reduce","acc","params","VALUE"],"sources":["C:/Users/Arber/Documents/GitHub/Food-delivery-app-LabCouse1/Food-delivery-app-LabCouse1/front-end-code/node_modules/@babel/helper-module-transforms/lib/index.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\r\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\r\nObject.defineProperty(exports, \"getModuleName\", {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _getModuleName.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"hasExports\", {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _normalizeAndLoadMetadata.hasExports;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"isModule\", {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _helperModuleImports.isModule;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"isSideEffectImport\", {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _normalizeAndLoadMetadata.isSideEffectImport;\r\n  }\r\n});\r\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\r\nObject.defineProperty(exports, \"rewriteThis\", {\r\n  enumerable: true,\r\n  get: function () {\r\n    return _rewriteThis.default;\r\n  }\r\n});\r\nexports.wrapInterop = wrapInterop;\r\n\r\nvar _assert = require(\"assert\");\r\n\r\nvar _t = require(\"@babel/types\");\r\n\r\nvar _template = require(\"@babel/template\");\r\n\r\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\r\n\r\nvar _rewriteThis = require(\"./rewrite-this\");\r\n\r\nvar _rewriteLiveReferences = require(\"./rewrite-live-references\");\r\n\r\nvar _normalizeAndLoadMetadata = require(\"./normalize-and-load-metadata\");\r\n\r\nvar _getModuleName = require(\"./get-module-name\");\r\n\r\nconst {\r\n  booleanLiteral,\r\n  callExpression,\r\n  cloneNode,\r\n  directive,\r\n  directiveLiteral,\r\n  expressionStatement,\r\n  identifier,\r\n  isIdentifier,\r\n  memberExpression,\r\n  stringLiteral,\r\n  valueToNode,\r\n  variableDeclaration,\r\n  variableDeclarator\r\n} = _t;\r\n\r\nfunction rewriteModuleStatementsAndPrepareHeader(path, {\r\n  loose,\r\n  exportName,\r\n  strict,\r\n  allowTopLevelThis,\r\n  strictMode,\r\n  noInterop,\r\n  importInterop = noInterop ? \"none\" : \"babel\",\r\n  lazy,\r\n  esNamespaceOnly,\r\n  constantReexports = loose,\r\n  enumerableModuleMeta = loose,\r\n  noIncompleteNsImportDetection\r\n}) {\r\n  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);\r\n\r\n  _assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\r\n\r\n  path.node.sourceType = \"script\";\r\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\r\n    importInterop,\r\n    initializeReexports: constantReexports,\r\n    lazy,\r\n    esNamespaceOnly\r\n  });\r\n\r\n  if (!allowTopLevelThis) {\r\n    (0, _rewriteThis.default)(path);\r\n  }\r\n\r\n  (0, _rewriteLiveReferences.default)(path, meta);\r\n\r\n  if (strictMode !== false) {\r\n    const hasStrict = path.node.directives.some(directive => {\r\n      return directive.value.value === \"use strict\";\r\n    });\r\n\r\n    if (!hasStrict) {\r\n      path.unshiftContainer(\"directives\", directive(directiveLiteral(\"use strict\")));\r\n    }\r\n  }\r\n\r\n  const headers = [];\r\n\r\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\r\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\r\n  }\r\n\r\n  const nameList = buildExportNameListDeclaration(path, meta);\r\n\r\n  if (nameList) {\r\n    meta.exportNameListName = nameList.name;\r\n    headers.push(nameList.statement);\r\n  }\r\n\r\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));\r\n  return {\r\n    meta,\r\n    headers\r\n  };\r\n}\r\n\r\nfunction ensureStatementsHoisted(statements) {\r\n  statements.forEach(header => {\r\n    header._blockHoist = 3;\r\n  });\r\n}\r\n\r\nfunction wrapInterop(programPath, expr, type) {\r\n  if (type === \"none\") {\r\n    return null;\r\n  }\r\n\r\n  if (type === \"node-namespace\") {\r\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [expr, booleanLiteral(true)]);\r\n  } else if (type === \"node-default\") {\r\n    return null;\r\n  }\r\n\r\n  let helper;\r\n\r\n  if (type === \"default\") {\r\n    helper = \"interopRequireDefault\";\r\n  } else if (type === \"namespace\") {\r\n    helper = \"interopRequireWildcard\";\r\n  } else {\r\n    throw new Error(`Unknown interop: ${type}`);\r\n  }\r\n\r\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\r\n}\r\n\r\nfunction buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false) {\r\n  const statements = [];\r\n  let srcNamespace = identifier(sourceMetadata.name);\r\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\r\n\r\n  for (const localName of sourceMetadata.importsNamespace) {\r\n    if (localName === sourceMetadata.name) continue;\r\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\r\n      NAME: localName,\r\n      SOURCE: cloneNode(srcNamespace)\r\n    }));\r\n  }\r\n\r\n  if (constantReexports) {\r\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\r\n  }\r\n\r\n  for (const exportName of sourceMetadata.reexportNamespace) {\r\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\r\n            Object.defineProperty(EXPORTS, \"NAME\", {\r\n              enumerable: true,\r\n              get: function() {\r\n                return NAMESPACE;\r\n              }\r\n            });\r\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\r\n      EXPORTS: metadata.exportName,\r\n      NAME: exportName,\r\n      NAMESPACE: cloneNode(srcNamespace)\r\n    }));\r\n  }\r\n\r\n  if (sourceMetadata.reexportAll) {\r\n    const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);\r\n    statement.loc = sourceMetadata.reexportAll.loc;\r\n    statements.push(statement);\r\n  }\r\n\r\n  return statements;\r\n}\r\n\r\nconst ReexportTemplate = {\r\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\r\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\r\n  spec: _template.default.statement`\r\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\r\n      enumerable: true,\r\n      get: function() {\r\n        return NAMESPACE_IMPORT;\r\n      },\r\n    });\r\n    `\r\n};\r\n\r\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\r\n  const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);\r\n  const {\r\n    stringSpecifiers\r\n  } = meta;\r\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\r\n    let NAMESPACE_IMPORT = cloneNode(namespace);\r\n\r\n    if (importName === \"default\" && metadata.interop === \"node-default\") {} else if (stringSpecifiers.has(importName)) {\r\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);\r\n    } else {\r\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));\r\n    }\r\n\r\n    const astNodes = {\r\n      EXPORTS: meta.exportName,\r\n      EXPORT_NAME: exportName,\r\n      NAMESPACE_IMPORT\r\n    };\r\n\r\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\r\n      if (stringSpecifiers.has(exportName)) {\r\n        return ReexportTemplate.constantComputed(astNodes);\r\n      } else {\r\n        return ReexportTemplate.constant(astNodes);\r\n      }\r\n    } else {\r\n      return ReexportTemplate.spec(astNodes);\r\n    }\r\n  });\r\n};\r\n\r\nfunction buildESModuleHeader(metadata, enumerableModuleMeta = false) {\r\n  return (enumerableModuleMeta ? _template.default.statement`\r\n        EXPORTS.__esModule = true;\r\n      ` : _template.default.statement`\r\n        Object.defineProperty(EXPORTS, \"__esModule\", {\r\n          value: true,\r\n        });\r\n      `)({\r\n    EXPORTS: metadata.exportName\r\n  });\r\n}\r\n\r\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\r\n  return (constantReexports ? _template.default.statement`\r\n        Object.keys(NAMESPACE).forEach(function(key) {\r\n          if (key === \"default\" || key === \"__esModule\") return;\r\n          VERIFY_NAME_LIST;\r\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\r\n\r\n          EXPORTS[key] = NAMESPACE[key];\r\n        });\r\n      ` : _template.default.statement`\r\n        Object.keys(NAMESPACE).forEach(function(key) {\r\n          if (key === \"default\" || key === \"__esModule\") return;\r\n          VERIFY_NAME_LIST;\r\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\r\n\r\n          Object.defineProperty(EXPORTS, key, {\r\n            enumerable: true,\r\n            get: function() {\r\n              return NAMESPACE[key];\r\n            },\r\n          });\r\n        });\r\n    `)({\r\n    NAMESPACE: namespace,\r\n    EXPORTS: metadata.exportName,\r\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\r\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\r\n          `({\r\n      EXPORTS_LIST: metadata.exportNameListName\r\n    }) : null\r\n  });\r\n}\r\n\r\nfunction buildExportNameListDeclaration(programPath, metadata) {\r\n  const exportedVars = Object.create(null);\r\n\r\n  for (const data of metadata.local.values()) {\r\n    for (const name of data.names) {\r\n      exportedVars[name] = true;\r\n    }\r\n  }\r\n\r\n  let hasReexport = false;\r\n\r\n  for (const data of metadata.source.values()) {\r\n    for (const exportName of data.reexports.keys()) {\r\n      exportedVars[exportName] = true;\r\n    }\r\n\r\n    for (const exportName of data.reexportNamespace) {\r\n      exportedVars[exportName] = true;\r\n    }\r\n\r\n    hasReexport = hasReexport || !!data.reexportAll;\r\n  }\r\n\r\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\r\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\r\n  delete exportedVars.default;\r\n  return {\r\n    name: name.name,\r\n    statement: variableDeclaration(\"var\", [variableDeclarator(name, valueToNode(exportedVars))])\r\n  };\r\n}\r\n\r\nfunction buildExportInitializationStatements(programPath, metadata, constantReexports = false, noIncompleteNsImportDetection = false) {\r\n  const initStatements = [];\r\n\r\n  for (const [localName, data] of metadata.local) {\r\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\r\n      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);\r\n    } else if (!noIncompleteNsImportDetection) {\r\n      for (const exportName of data.names) {\r\n        initStatements.push([exportName, null]);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const data of metadata.source.values()) {\r\n    if (!constantReexports) {\r\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\r\n      const reexports = [...data.reexports.keys()];\r\n\r\n      for (let i = 0; i < reexportsStatements.length; i++) {\r\n        initStatements.push([reexports[i], reexportsStatements[i]]);\r\n      }\r\n    }\r\n\r\n    if (!noIncompleteNsImportDetection) {\r\n      for (const exportName of data.reexportNamespace) {\r\n        initStatements.push([exportName, null]);\r\n      }\r\n    }\r\n  }\r\n\r\n  initStatements.sort(([a], [b]) => {\r\n    if (a < b) return -1;\r\n    if (b < a) return 1;\r\n    return 0;\r\n  });\r\n  const results = [];\r\n\r\n  if (noIncompleteNsImportDetection) {\r\n    for (const [, initStatement] of initStatements) {\r\n      results.push(initStatement);\r\n    }\r\n  } else {\r\n    const chunkSize = 100;\r\n\r\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\r\n      let uninitializedExportNames = [];\r\n\r\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\r\n        const [exportName, initStatement] = initStatements[i + j];\r\n\r\n        if (initStatement !== null) {\r\n          if (uninitializedExportNames.length > 0) {\r\n            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\r\n            uninitializedExportNames = [];\r\n          }\r\n\r\n          results.push(initStatement);\r\n        } else {\r\n          uninitializedExportNames.push(exportName);\r\n        }\r\n      }\r\n\r\n      if (uninitializedExportNames.length > 0) {\r\n        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\r\n      }\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nconst InitTemplate = {\r\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\r\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\r\n};\r\n\r\nfunction buildInitStatement(metadata, exportNames, initExpr) {\r\n  const {\r\n    stringSpecifiers,\r\n    exportName: EXPORTS\r\n  } = metadata;\r\n  return expressionStatement(exportNames.reduce((acc, exportName) => {\r\n    const params = {\r\n      EXPORTS,\r\n      NAME: exportName,\r\n      VALUE: acc\r\n    };\r\n\r\n    if (stringSpecifiers.has(exportName)) {\r\n      return InitTemplate.computed(params);\r\n    } else {\r\n      return InitTemplate.default(params);\r\n    }\r\n  }, initExpr));\r\n}"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,4BAAR,GAAuCA,4BAAvC;AACAF,OAAO,CAACG,uBAAR,GAAkCA,uBAAlC;AACAL,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,eAA/B,EAAgD;EAC9CI,UAAU,EAAE,IADkC;EAE9CC,GAAG,EAAE,YAAY;IACf,OAAOC,cAAc,CAACC,OAAtB;EACD;AAJ6C,CAAhD;AAMAT,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CI,UAAU,EAAE,IAD+B;EAE3CC,GAAG,EAAE,YAAY;IACf,OAAOG,yBAAyB,CAACC,UAAjC;EACD;AAJ0C,CAA7C;AAMAX,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,UAA/B,EAA2C;EACzCI,UAAU,EAAE,IAD6B;EAEzCC,GAAG,EAAE,YAAY;IACf,OAAOK,oBAAoB,CAACC,QAA5B;EACD;AAJwC,CAA3C;AAMAb,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,oBAA/B,EAAqD;EACnDI,UAAU,EAAE,IADuC;EAEnDC,GAAG,EAAE,YAAY;IACf,OAAOG,yBAAyB,CAACI,kBAAjC;EACD;AAJkD,CAArD;AAMAZ,OAAO,CAACa,uCAAR,GAAkDA,uCAAlD;AACAf,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,aAA/B,EAA8C;EAC5CI,UAAU,EAAE,IADgC;EAE5CC,GAAG,EAAE,YAAY;IACf,OAAOS,YAAY,CAACP,OAApB;EACD;AAJ2C,CAA9C;AAMAP,OAAO,CAACe,WAAR,GAAsBA,WAAtB;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,QAAD,CAArB;;AAEA,IAAIC,EAAE,GAAGD,OAAO,CAAC,cAAD,CAAhB;;AAEA,IAAIE,SAAS,GAAGF,OAAO,CAAC,iBAAD,CAAvB;;AAEA,IAAIP,oBAAoB,GAAGO,OAAO,CAAC,8BAAD,CAAlC;;AAEA,IAAIH,YAAY,GAAGG,OAAO,CAAC,gBAAD,CAA1B;;AAEA,IAAIG,sBAAsB,GAAGH,OAAO,CAAC,2BAAD,CAApC;;AAEA,IAAIT,yBAAyB,GAAGS,OAAO,CAAC,+BAAD,CAAvC;;AAEA,IAAIX,cAAc,GAAGW,OAAO,CAAC,mBAAD,CAA5B;;AAEA,MAAM;EACJI,cADI;EAEJC,cAFI;EAGJC,SAHI;EAIJC,SAJI;EAKJC,gBALI;EAMJC,mBANI;EAOJC,UAPI;EAQJC,YARI;EASJC,gBATI;EAUJC,aAVI;EAWJC,WAXI;EAYJC,mBAZI;EAaJC;AAbI,IAcFf,EAdJ;;AAgBA,SAASL,uCAAT,CAAiDqB,IAAjD,QAaG;EAAA,IAboD;IACrDC,KADqD;IAErDC,UAFqD;IAGrDC,MAHqD;IAIrDC,iBAJqD;IAKrDC,UALqD;IAMrDC,SANqD;IAOrDC,aAAa,GAAGD,SAAS,GAAG,MAAH,GAAY,OAPgB;IAQrDE,IARqD;IASrDC,eATqD;IAUrDC,iBAAiB,GAAGT,KAViC;IAWrDU,oBAAoB,GAAGV,KAX8B;IAYrDW;EAZqD,CAapD;EACD,CAAC,GAAGtC,yBAAyB,CAACuC,2BAA9B,EAA2DN,aAA3D;;EAEAzB,OAAO,CAAC,CAAC,GAAGN,oBAAoB,CAACC,QAAzB,EAAmCuB,IAAnC,CAAD,EAA2C,8CAA3C,CAAP;;EAEAA,IAAI,CAACc,IAAL,CAAUC,UAAV,GAAuB,QAAvB;EACA,MAAMC,IAAI,GAAG,CAAC,GAAG1C,yBAAyB,CAACD,OAA9B,EAAuC2B,IAAvC,EAA6CE,UAA7C,EAAyD;IACpEK,aADoE;IAEpEU,mBAAmB,EAAEP,iBAF+C;IAGpEF,IAHoE;IAIpEC;EAJoE,CAAzD,CAAb;;EAOA,IAAI,CAACL,iBAAL,EAAwB;IACtB,CAAC,GAAGxB,YAAY,CAACP,OAAjB,EAA0B2B,IAA1B;EACD;;EAED,CAAC,GAAGd,sBAAsB,CAACb,OAA3B,EAAoC2B,IAApC,EAA0CgB,IAA1C;;EAEA,IAAIX,UAAU,KAAK,KAAnB,EAA0B;IACxB,MAAMa,SAAS,GAAGlB,IAAI,CAACc,IAAL,CAAUK,UAAV,CAAqBC,IAArB,CAA0B9B,SAAS,IAAI;MACvD,OAAOA,SAAS,CAACvB,KAAV,CAAgBA,KAAhB,KAA0B,YAAjC;IACD,CAFiB,CAAlB;;IAIA,IAAI,CAACmD,SAAL,EAAgB;MACdlB,IAAI,CAACqB,gBAAL,CAAsB,YAAtB,EAAoC/B,SAAS,CAACC,gBAAgB,CAAC,YAAD,CAAjB,CAA7C;IACD;EACF;;EAED,MAAM+B,OAAO,GAAG,EAAhB;;EAEA,IAAI,CAAC,GAAGhD,yBAAyB,CAACC,UAA9B,EAA0CyC,IAA1C,KAAmD,CAACb,MAAxD,EAAgE;IAC9DmB,OAAO,CAACC,IAAR,CAAaC,mBAAmB,CAACR,IAAD,EAAOL,oBAAP,CAAhC;EACD;;EAED,MAAMc,QAAQ,GAAGC,8BAA8B,CAAC1B,IAAD,EAAOgB,IAAP,CAA/C;;EAEA,IAAIS,QAAJ,EAAc;IACZT,IAAI,CAACW,kBAAL,GAA0BF,QAAQ,CAACG,IAAnC;IACAN,OAAO,CAACC,IAAR,CAAaE,QAAQ,CAACI,SAAtB;EACD;;EAEDP,OAAO,CAACC,IAAR,CAAa,GAAGO,mCAAmC,CAAC9B,IAAD,EAAOgB,IAAP,EAAaN,iBAAb,EAAgCE,6BAAhC,CAAnD;EACA,OAAO;IACLI,IADK;IAELM;EAFK,CAAP;AAID;;AAED,SAASrD,uBAAT,CAAiC8D,UAAjC,EAA6C;EAC3CA,UAAU,CAACC,OAAX,CAAmBC,MAAM,IAAI;IAC3BA,MAAM,CAACC,WAAP,GAAqB,CAArB;EACD,CAFD;AAGD;;AAED,SAASrD,WAAT,CAAqBsD,WAArB,EAAkCC,IAAlC,EAAwCC,IAAxC,EAA8C;EAC5C,IAAIA,IAAI,KAAK,MAAb,EAAqB;IACnB,OAAO,IAAP;EACD;;EAED,IAAIA,IAAI,KAAK,gBAAb,EAA+B;IAC7B,OAAOjD,cAAc,CAAC+C,WAAW,CAACG,GAAZ,CAAgBC,SAAhB,CAA0B,wBAA1B,CAAD,EAAsD,CAACH,IAAD,EAAOjD,cAAc,CAAC,IAAD,CAArB,CAAtD,CAArB;EACD,CAFD,MAEO,IAAIkD,IAAI,KAAK,cAAb,EAA6B;IAClC,OAAO,IAAP;EACD;;EAED,IAAIG,MAAJ;;EAEA,IAAIH,IAAI,KAAK,SAAb,EAAwB;IACtBG,MAAM,GAAG,uBAAT;EACD,CAFD,MAEO,IAAIH,IAAI,KAAK,WAAb,EAA0B;IAC/BG,MAAM,GAAG,wBAAT;EACD,CAFM,MAEA;IACL,MAAM,IAAIC,KAAJ,CAAW,oBAAmBJ,IAAK,EAAnC,CAAN;EACD;;EAED,OAAOjD,cAAc,CAAC+C,WAAW,CAACG,GAAZ,CAAgBC,SAAhB,CAA0BC,MAA1B,CAAD,EAAoC,CAACJ,IAAD,CAApC,CAArB;AACD;;AAED,SAASpE,4BAAT,CAAsC0E,QAAtC,EAAgDC,cAAhD,EAA2F;EAAA,IAA3BjC,iBAA2B,uEAAP,KAAO;EACzF,MAAMqB,UAAU,GAAG,EAAnB;EACA,IAAIa,YAAY,GAAGnD,UAAU,CAACkD,cAAc,CAACf,IAAhB,CAA7B;EACA,IAAIe,cAAc,CAACnC,IAAnB,EAAyBoC,YAAY,GAAGxD,cAAc,CAACwD,YAAD,EAAe,EAAf,CAA7B;;EAEzB,KAAK,MAAMC,SAAX,IAAwBF,cAAc,CAACG,gBAAvC,EAAyD;IACvD,IAAID,SAAS,KAAKF,cAAc,CAACf,IAAjC,EAAuC;IACvCG,UAAU,CAACR,IAAX,CAAgBtC,SAAS,CAACZ,OAAV,CAAkBwD,SAAU,oBAA5B,CAAgD;MAC9DkB,IAAI,EAAEF,SADwD;MAE9DG,MAAM,EAAE3D,SAAS,CAACuD,YAAD;IAF6C,CAAhD,CAAhB;EAID;;EAED,IAAIlC,iBAAJ,EAAuB;IACrBqB,UAAU,CAACR,IAAX,CAAgB,GAAG0B,sBAAsB,CAACP,QAAD,EAAWC,cAAX,EAA2B,IAA3B,CAAzC;EACD;;EAED,KAAK,MAAMzC,UAAX,IAAyByC,cAAc,CAACO,iBAAxC,EAA2D;IACzDnB,UAAU,CAACR,IAAX,CAAgB,CAACoB,cAAc,CAACnC,IAAf,GAAsBvB,SAAS,CAACZ,OAAV,CAAkBwD,SAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,WAPqB,GAOP5C,SAAS,CAACZ,OAAV,CAAkBwD,SAAU,2BAPtB,EAOkD;MAChEsB,OAAO,EAAET,QAAQ,CAACxC,UAD8C;MAEhE6C,IAAI,EAAE7C,UAF0D;MAGhEkD,SAAS,EAAE/D,SAAS,CAACuD,YAAD;IAH4C,CAPlD,CAAhB;EAYD;;EAED,IAAID,cAAc,CAACU,WAAnB,EAAgC;IAC9B,MAAMxB,SAAS,GAAGyB,sBAAsB,CAACZ,QAAD,EAAWrD,SAAS,CAACuD,YAAD,CAApB,EAAoClC,iBAApC,CAAxC;IACAmB,SAAS,CAAC0B,GAAV,GAAgBZ,cAAc,CAACU,WAAf,CAA2BE,GAA3C;IACAxB,UAAU,CAACR,IAAX,CAAgBM,SAAhB;EACD;;EAED,OAAOE,UAAP;AACD;;AAED,MAAMyB,gBAAgB,GAAG;EACvBC,QAAQ,EAAExE,SAAS,CAACZ,OAAV,CAAkBwD,SAAU,yCADf;EAEvB6B,gBAAgB,EAAEzE,SAAS,CAACZ,OAAV,CAAkBwD,SAAU,4CAFvB;EAGvB8B,IAAI,EAAE1E,SAAS,CAACZ,OAAV,CAAkBwD,SAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AAVyB,CAAzB;;AAaA,MAAMoB,sBAAsB,GAAG,CAACjC,IAAD,EAAO0B,QAAP,EAAiBhC,iBAAjB,KAAuC;EACpE,MAAMkD,SAAS,GAAGlB,QAAQ,CAAClC,IAAT,GAAgBpB,cAAc,CAACK,UAAU,CAACiD,QAAQ,CAACd,IAAV,CAAX,EAA4B,EAA5B,CAA9B,GAAgEnC,UAAU,CAACiD,QAAQ,CAACd,IAAV,CAA5F;EACA,MAAM;IACJiC;EADI,IAEF7C,IAFJ;EAGA,OAAO8C,KAAK,CAACC,IAAN,CAAWrB,QAAQ,CAACsB,SAApB,EAA+B,SAA8B;IAAA,IAA7B,CAAC9D,UAAD,EAAa+D,UAAb,CAA6B;IAClE,IAAIC,gBAAgB,GAAG7E,SAAS,CAACuE,SAAD,CAAhC;;IAEA,IAAIK,UAAU,KAAK,SAAf,IAA4BvB,QAAQ,CAACyB,OAAT,KAAqB,cAArD,EAAqE,CAAE,CAAvE,MAA6E,IAAIN,gBAAgB,CAACO,GAAjB,CAAqBH,UAArB,CAAJ,EAAsC;MACjHC,gBAAgB,GAAGvE,gBAAgB,CAACuE,gBAAD,EAAmBtE,aAAa,CAACqE,UAAD,CAAhC,EAA8C,IAA9C,CAAnC;IACD,CAF4E,MAEtE;MACLC,gBAAgB,GAAGvE,gBAAgB,CAACuE,gBAAD,EAAmBzE,UAAU,CAACwE,UAAD,CAA7B,CAAnC;IACD;;IAED,MAAMI,QAAQ,GAAG;MACflB,OAAO,EAAEnC,IAAI,CAACd,UADC;MAEfoE,WAAW,EAAEpE,UAFE;MAGfgE;IAHe,CAAjB;;IAMA,IAAIxD,iBAAiB,IAAIhB,YAAY,CAACwE,gBAAD,CAArC,EAAyD;MACvD,IAAIL,gBAAgB,CAACO,GAAjB,CAAqBlE,UAArB,CAAJ,EAAsC;QACpC,OAAOsD,gBAAgB,CAACE,gBAAjB,CAAkCW,QAAlC,CAAP;MACD,CAFD,MAEO;QACL,OAAOb,gBAAgB,CAACC,QAAjB,CAA0BY,QAA1B,CAAP;MACD;IACF,CAND,MAMO;MACL,OAAOb,gBAAgB,CAACG,IAAjB,CAAsBU,QAAtB,CAAP;IACD;EACF,CAxBM,CAAP;AAyBD,CA9BD;;AAgCA,SAAS7C,mBAAT,CAA6BkB,QAA7B,EAAqE;EAAA,IAA9B/B,oBAA8B,uEAAP,KAAO;EACnE,OAAO,CAACA,oBAAoB,GAAG1B,SAAS,CAACZ,OAAV,CAAkBwD,SAAU;AAC7D;AACA,OAF8B,GAEpB5C,SAAS,CAACZ,OAAV,CAAkBwD,SAAU;AACtC;AACA;AACA;AACA,OANS,EAMA;IACLsB,OAAO,EAAET,QAAQ,CAACxC;EADb,CANA,CAAP;AASD;;AAED,SAASoD,sBAAT,CAAgCZ,QAAhC,EAA0CkB,SAA1C,EAAqDlD,iBAArD,EAAwE;EACtE,OAAO,CAACA,iBAAiB,GAAGzB,SAAS,CAACZ,OAAV,CAAkBwD,SAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAR2B,GAQjB5C,SAAS,CAACZ,OAAV,CAAkBwD,SAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KArBS,EAqBF;IACHuB,SAAS,EAAEQ,SADR;IAEHT,OAAO,EAAET,QAAQ,CAACxC,UAFf;IAGHqE,gBAAgB,EAAE7B,QAAQ,CAACf,kBAAT,GAA8B,CAAC,GAAG1C,SAAS,CAACZ,OAAd,CAAuB;AAC3E;AACA,WAFoD,CAExC;MACNmG,YAAY,EAAE9B,QAAQ,CAACf;IADjB,CAFwC,CAA9B,GAIb;EAPF,CArBE,CAAP;AA8BD;;AAED,SAASD,8BAAT,CAAwCS,WAAxC,EAAqDO,QAArD,EAA+D;EAC7D,MAAM+B,YAAY,GAAG7G,MAAM,CAAC8G,MAAP,CAAc,IAAd,CAArB;;EAEA,KAAK,MAAMC,IAAX,IAAmBjC,QAAQ,CAACkC,KAAT,CAAeC,MAAf,EAAnB,EAA4C;IAC1C,KAAK,MAAMjD,IAAX,IAAmB+C,IAAI,CAACG,KAAxB,EAA+B;MAC7BL,YAAY,CAAC7C,IAAD,CAAZ,GAAqB,IAArB;IACD;EACF;;EAED,IAAImD,WAAW,GAAG,KAAlB;;EAEA,KAAK,MAAMJ,IAAX,IAAmBjC,QAAQ,CAACsC,MAAT,CAAgBH,MAAhB,EAAnB,EAA6C;IAC3C,KAAK,MAAM3E,UAAX,IAAyByE,IAAI,CAACX,SAAL,CAAeiB,IAAf,EAAzB,EAAgD;MAC9CR,YAAY,CAACvE,UAAD,CAAZ,GAA2B,IAA3B;IACD;;IAED,KAAK,MAAMA,UAAX,IAAyByE,IAAI,CAACzB,iBAA9B,EAAiD;MAC/CuB,YAAY,CAACvE,UAAD,CAAZ,GAA2B,IAA3B;IACD;;IAED6E,WAAW,GAAGA,WAAW,IAAI,CAAC,CAACJ,IAAI,CAACtB,WAApC;EACD;;EAED,IAAI,CAAC0B,WAAD,IAAgBnH,MAAM,CAACqH,IAAP,CAAYR,YAAZ,EAA0BS,MAA1B,KAAqC,CAAzD,EAA4D,OAAO,IAAP;EAC5D,MAAMtD,IAAI,GAAGO,WAAW,CAACgD,KAAZ,CAAkBC,qBAAlB,CAAwC,aAAxC,CAAb;EACA,OAAOX,YAAY,CAACpG,OAApB;EACA,OAAO;IACLuD,IAAI,EAAEA,IAAI,CAACA,IADN;IAELC,SAAS,EAAE/B,mBAAmB,CAAC,KAAD,EAAQ,CAACC,kBAAkB,CAAC6B,IAAD,EAAO/B,WAAW,CAAC4E,YAAD,CAAlB,CAAnB,CAAR;EAFzB,CAAP;AAID;;AAED,SAAS3C,mCAAT,CAA6CK,WAA7C,EAA0DO,QAA1D,EAAsI;EAAA,IAAlEhC,iBAAkE,uEAA9C,KAA8C;EAAA,IAAvCE,6BAAuC,uEAAP,KAAO;EACpI,MAAMyE,cAAc,GAAG,EAAvB;;EAEA,KAAK,MAAM,CAACxC,SAAD,EAAY8B,IAAZ,CAAX,IAAgCjC,QAAQ,CAACkC,KAAzC,EAAgD;IAC9C,IAAID,IAAI,CAACW,IAAL,KAAc,QAAlB,EAA4B,CAAE,CAA9B,MAAoC,IAAIX,IAAI,CAACW,IAAL,KAAc,SAAlB,EAA6B;MAC/DD,cAAc,CAAC9D,IAAf,CAAoB,CAACoD,IAAI,CAACG,KAAL,CAAW,CAAX,CAAD,EAAgBS,kBAAkB,CAAC7C,QAAD,EAAWiC,IAAI,CAACG,KAAhB,EAAuBrF,UAAU,CAACoD,SAAD,CAAjC,CAAlC,CAApB;IACD,CAFmC,MAE7B,IAAI,CAACjC,6BAAL,EAAoC;MACzC,KAAK,MAAMV,UAAX,IAAyByE,IAAI,CAACG,KAA9B,EAAqC;QACnCO,cAAc,CAAC9D,IAAf,CAAoB,CAACrB,UAAD,EAAa,IAAb,CAApB;MACD;IACF;EACF;;EAED,KAAK,MAAMyE,IAAX,IAAmBjC,QAAQ,CAACsC,MAAT,CAAgBH,MAAhB,EAAnB,EAA6C;IAC3C,IAAI,CAACnE,iBAAL,EAAwB;MACtB,MAAM8E,mBAAmB,GAAGvC,sBAAsB,CAACP,QAAD,EAAWiC,IAAX,EAAiB,KAAjB,CAAlD;MACA,MAAMX,SAAS,GAAG,CAAC,GAAGW,IAAI,CAACX,SAAL,CAAeiB,IAAf,EAAJ,CAAlB;;MAEA,KAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,mBAAmB,CAACN,MAAxC,EAAgDO,CAAC,EAAjD,EAAqD;QACnDJ,cAAc,CAAC9D,IAAf,CAAoB,CAACyC,SAAS,CAACyB,CAAD,CAAV,EAAeD,mBAAmB,CAACC,CAAD,CAAlC,CAApB;MACD;IACF;;IAED,IAAI,CAAC7E,6BAAL,EAAoC;MAClC,KAAK,MAAMV,UAAX,IAAyByE,IAAI,CAACzB,iBAA9B,EAAiD;QAC/CmC,cAAc,CAAC9D,IAAf,CAAoB,CAACrB,UAAD,EAAa,IAAb,CAApB;MACD;IACF;EACF;;EAEDmF,cAAc,CAACK,IAAf,CAAoB,kBAAc;IAAA,IAAb,CAACC,CAAD,CAAa;IAAA,IAAR,CAACC,CAAD,CAAQ;IAChC,IAAID,CAAC,GAAGC,CAAR,EAAW,OAAO,CAAC,CAAR;IACX,IAAIA,CAAC,GAAGD,CAAR,EAAW,OAAO,CAAP;IACX,OAAO,CAAP;EACD,CAJD;EAKA,MAAME,OAAO,GAAG,EAAhB;;EAEA,IAAIjF,6BAAJ,EAAmC;IACjC,KAAK,MAAM,GAAGkF,aAAH,CAAX,IAAgCT,cAAhC,EAAgD;MAC9CQ,OAAO,CAACtE,IAAR,CAAauE,aAAb;IACD;EACF,CAJD,MAIO;IACL,MAAMC,SAAS,GAAG,GAAlB;;IAEA,KAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,cAAc,CAACH,MAAnC,EAA2CO,CAAC,IAAIM,SAAhD,EAA2D;MACzD,IAAIC,wBAAwB,GAAG,EAA/B;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAJ,IAAiBN,CAAC,GAAGQ,CAAJ,GAAQZ,cAAc,CAACH,MAAxD,EAAgEe,CAAC,EAAjE,EAAqE;QACnE,MAAM,CAAC/F,UAAD,EAAa4F,aAAb,IAA8BT,cAAc,CAACI,CAAC,GAAGQ,CAAL,CAAlD;;QAEA,IAAIH,aAAa,KAAK,IAAtB,EAA4B;UAC1B,IAAIE,wBAAwB,CAACd,MAAzB,GAAkC,CAAtC,EAAyC;YACvCW,OAAO,CAACtE,IAAR,CAAagE,kBAAkB,CAAC7C,QAAD,EAAWsD,wBAAX,EAAqC7D,WAAW,CAACgD,KAAZ,CAAkBe,kBAAlB,EAArC,CAA/B;YACAF,wBAAwB,GAAG,EAA3B;UACD;;UAEDH,OAAO,CAACtE,IAAR,CAAauE,aAAb;QACD,CAPD,MAOO;UACLE,wBAAwB,CAACzE,IAAzB,CAA8BrB,UAA9B;QACD;MACF;;MAED,IAAI8F,wBAAwB,CAACd,MAAzB,GAAkC,CAAtC,EAAyC;QACvCW,OAAO,CAACtE,IAAR,CAAagE,kBAAkB,CAAC7C,QAAD,EAAWsD,wBAAX,EAAqC7D,WAAW,CAACgD,KAAZ,CAAkBe,kBAAlB,EAArC,CAA/B;MACD;IACF;EACF;;EAED,OAAOL,OAAP;AACD;;AAED,MAAMM,YAAY,GAAG;EACnBC,QAAQ,EAAEnH,SAAS,CAACZ,OAAV,CAAkBgI,UAAW,yBADpB;EAEnBhI,OAAO,EAAEY,SAAS,CAACZ,OAAV,CAAkBgI,UAAW;AAFnB,CAArB;;AAKA,SAASd,kBAAT,CAA4B7C,QAA5B,EAAsC4D,WAAtC,EAAmDC,QAAnD,EAA6D;EAC3D,MAAM;IACJ1C,gBADI;IAEJ3D,UAAU,EAAEiD;EAFR,IAGFT,QAHJ;EAIA,OAAOlD,mBAAmB,CAAC8G,WAAW,CAACE,MAAZ,CAAmB,CAACC,GAAD,EAAMvG,UAAN,KAAqB;IACjE,MAAMwG,MAAM,GAAG;MACbvD,OADa;MAEbJ,IAAI,EAAE7C,UAFO;MAGbyG,KAAK,EAAEF;IAHM,CAAf;;IAMA,IAAI5C,gBAAgB,CAACO,GAAjB,CAAqBlE,UAArB,CAAJ,EAAsC;MACpC,OAAOiG,YAAY,CAACC,QAAb,CAAsBM,MAAtB,CAAP;IACD,CAFD,MAEO;MACL,OAAOP,YAAY,CAAC9H,OAAb,CAAqBqI,MAArB,CAAP;IACD;EACF,CAZ0B,EAYxBH,QAZwB,CAAD,CAA1B;AAaD"},"metadata":{},"sourceType":"script"}