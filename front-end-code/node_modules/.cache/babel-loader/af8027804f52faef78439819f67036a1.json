{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isCallExpression,\n  isClassDeclaration,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    arrowBody: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, {\n    expressionStatement: true\n  });\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, {\n      expressionStatement: isFollowedByBracket,\n      forHead: isFollowedByBracket,\n      forInHead: isFollowedByBracket,\n      forOfHead: true\n    });\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, _ref) {\n  let {\n    expressionStatement = false,\n    arrowBody = false,\n    exportDefault = false,\n    forHead = false,\n    forInHead = false,\n    forOfHead = false\n  } = _ref;\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ArrowFunctionExpression","AssignmentExpression","Binary","BinaryExpression","ClassExpression","ConditionalExpression","DoExpression","FunctionExpression","FunctionTypeAnnotation","Identifier","LogicalExpression","NullableTypeAnnotation","ObjectExpression","OptionalIndexedAccessType","OptionalCallExpression","OptionalMemberExpression","SequenceExpression","TSAsExpression","TSInferType","TSTypeAssertion","TSIntersectionType","TSUnionType","UnaryLike","IntersectionTypeAnnotation","UnionTypeAnnotation","UpdateExpression","AwaitExpression","YieldExpression","_t","require","isArrayTypeAnnotation","isArrowFunctionExpression","isAssignmentExpression","isAwaitExpression","isBinary","isBinaryExpression","isCallExpression","isClassDeclaration","isClassExpression","isConditional","isConditionalExpression","isExportDeclaration","isExportDefaultDeclaration","isExpressionStatement","isFor","isForInStatement","isForOfStatement","isForStatement","isIfStatement","isIndexedAccessType","isIntersectionTypeAnnotation","isLogicalExpression","isMemberExpression","isNewExpression","isNullableTypeAnnotation","isObjectPattern","isOptionalCallExpression","isOptionalMemberExpression","isReturnStatement","isSequenceExpression","isSwitchStatement","isTSArrayType","isTSAsExpression","isTSIntersectionType","isTSNonNullExpression","isTSOptionalType","isTSRestType","isTSTypeAssertion","isTSUnionType","isTaggedTemplateExpression","isThrowStatement","isTypeAnnotation","isUnaryLike","isUnionTypeAnnotation","isVariableDeclarator","isWhileStatement","isYieldExpression","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","superClass","hasPostfixPart","object","callee","tag","printStack","length","isFirstInContext","expressionStatement","arrowBody","async","operator","left","parentOp","parentPos","nodeOp","nodePos","right","objectType","test","discriminant","expression","exportDefault","name","isFollowedByBracket","computed","optional","forHead","forInHead","forOfHead","i","declaration","body","init","expressions"],"sources":["C:/Users/Arber/Documents/GitHub/Food-delivery-app-LabCouse1/Food-delivery-app-LabCouse1/front-end-code/node_modules/@babel/generator/lib/node/parentheses.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\r\nexports.AssignmentExpression = AssignmentExpression;\r\nexports.Binary = Binary;\r\nexports.BinaryExpression = BinaryExpression;\r\nexports.ClassExpression = ClassExpression;\r\nexports.ConditionalExpression = ConditionalExpression;\r\nexports.DoExpression = DoExpression;\r\nexports.FunctionExpression = FunctionExpression;\r\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\r\nexports.Identifier = Identifier;\r\nexports.LogicalExpression = LogicalExpression;\r\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\r\nexports.ObjectExpression = ObjectExpression;\r\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\r\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\r\nexports.SequenceExpression = SequenceExpression;\r\nexports.TSAsExpression = TSAsExpression;\r\nexports.TSInferType = TSInferType;\r\nexports.TSTypeAssertion = TSTypeAssertion;\r\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\r\nexports.UnaryLike = UnaryLike;\r\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\r\nexports.UpdateExpression = UpdateExpression;\r\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\r\n\r\nvar _t = require(\"@babel/types\");\r\n\r\nconst {\r\n  isArrayTypeAnnotation,\r\n  isArrowFunctionExpression,\r\n  isAssignmentExpression,\r\n  isAwaitExpression,\r\n  isBinary,\r\n  isBinaryExpression,\r\n  isCallExpression,\r\n  isClassDeclaration,\r\n  isClassExpression,\r\n  isConditional,\r\n  isConditionalExpression,\r\n  isExportDeclaration,\r\n  isExportDefaultDeclaration,\r\n  isExpressionStatement,\r\n  isFor,\r\n  isForInStatement,\r\n  isForOfStatement,\r\n  isForStatement,\r\n  isIfStatement,\r\n  isIndexedAccessType,\r\n  isIntersectionTypeAnnotation,\r\n  isLogicalExpression,\r\n  isMemberExpression,\r\n  isNewExpression,\r\n  isNullableTypeAnnotation,\r\n  isObjectPattern,\r\n  isOptionalCallExpression,\r\n  isOptionalMemberExpression,\r\n  isReturnStatement,\r\n  isSequenceExpression,\r\n  isSwitchStatement,\r\n  isTSArrayType,\r\n  isTSAsExpression,\r\n  isTSIntersectionType,\r\n  isTSNonNullExpression,\r\n  isTSOptionalType,\r\n  isTSRestType,\r\n  isTSTypeAssertion,\r\n  isTSUnionType,\r\n  isTaggedTemplateExpression,\r\n  isThrowStatement,\r\n  isTypeAnnotation,\r\n  isUnaryLike,\r\n  isUnionTypeAnnotation,\r\n  isVariableDeclarator,\r\n  isWhileStatement,\r\n  isYieldExpression\r\n} = _t;\r\nconst PRECEDENCE = {\r\n  \"||\": 0,\r\n  \"??\": 0,\r\n  \"&&\": 1,\r\n  \"|\": 2,\r\n  \"^\": 3,\r\n  \"&\": 4,\r\n  \"==\": 5,\r\n  \"===\": 5,\r\n  \"!=\": 5,\r\n  \"!==\": 5,\r\n  \"<\": 6,\r\n  \">\": 6,\r\n  \"<=\": 6,\r\n  \">=\": 6,\r\n  in: 6,\r\n  instanceof: 6,\r\n  \">>\": 7,\r\n  \"<<\": 7,\r\n  \">>>\": 7,\r\n  \"+\": 8,\r\n  \"-\": 8,\r\n  \"*\": 9,\r\n  \"/\": 9,\r\n  \"%\": 9,\r\n  \"**\": 10\r\n};\r\n\r\nconst isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;\r\n\r\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\r\n\r\nfunction NullableTypeAnnotation(node, parent) {\r\n  return isArrayTypeAnnotation(parent);\r\n}\r\n\r\nfunction FunctionTypeAnnotation(node, parent, printStack) {\r\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\r\n}\r\n\r\nfunction UpdateExpression(node, parent) {\r\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\r\n}\r\n\r\nfunction ObjectExpression(node, parent, printStack) {\r\n  return isFirstInContext(printStack, {\r\n    expressionStatement: true,\r\n    arrowBody: true\r\n  });\r\n}\r\n\r\nfunction DoExpression(node, parent, printStack) {\r\n  return !node.async && isFirstInContext(printStack, {\r\n    expressionStatement: true\r\n  });\r\n}\r\n\r\nfunction Binary(node, parent) {\r\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\r\n    operator: \"**\"\r\n  })) {\r\n    return parent.left === node;\r\n  }\r\n\r\n  if (isClassExtendsClause(node, parent)) {\r\n    return true;\r\n  }\r\n\r\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\r\n    return true;\r\n  }\r\n\r\n  if (isBinary(parent)) {\r\n    const parentOp = parent.operator;\r\n    const parentPos = PRECEDENCE[parentOp];\r\n    const nodeOp = node.operator;\r\n    const nodePos = PRECEDENCE[nodeOp];\r\n\r\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction UnionTypeAnnotation(node, parent) {\r\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\r\n}\r\n\r\nfunction OptionalIndexedAccessType(node, parent) {\r\n  return isIndexedAccessType(parent, {\r\n    objectType: node\r\n  });\r\n}\r\n\r\nfunction TSAsExpression() {\r\n  return true;\r\n}\r\n\r\nfunction TSTypeAssertion() {\r\n  return true;\r\n}\r\n\r\nfunction TSUnionType(node, parent) {\r\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\r\n}\r\n\r\nfunction TSInferType(node, parent) {\r\n  return isTSArrayType(parent) || isTSOptionalType(parent);\r\n}\r\n\r\nfunction BinaryExpression(node, parent) {\r\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\r\n}\r\n\r\nfunction SequenceExpression(node, parent) {\r\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction YieldExpression(node, parent) {\r\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\r\n}\r\n\r\nfunction ClassExpression(node, parent, printStack) {\r\n  return isFirstInContext(printStack, {\r\n    expressionStatement: true,\r\n    exportDefault: true\r\n  });\r\n}\r\n\r\nfunction UnaryLike(node, parent) {\r\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\r\n    operator: \"**\",\r\n    left: node\r\n  }) || isClassExtendsClause(node, parent);\r\n}\r\n\r\nfunction FunctionExpression(node, parent, printStack) {\r\n  return isFirstInContext(printStack, {\r\n    expressionStatement: true,\r\n    exportDefault: true\r\n  });\r\n}\r\n\r\nfunction ArrowFunctionExpression(node, parent) {\r\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\r\n}\r\n\r\nfunction ConditionalExpression(node, parent) {\r\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\r\n    test: node\r\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\r\n    return true;\r\n  }\r\n\r\n  return UnaryLike(node, parent);\r\n}\r\n\r\nfunction OptionalMemberExpression(node, parent) {\r\n  return isCallExpression(parent, {\r\n    callee: node\r\n  }) || isMemberExpression(parent, {\r\n    object: node\r\n  });\r\n}\r\n\r\nfunction AssignmentExpression(node, parent) {\r\n  if (isObjectPattern(node.left)) {\r\n    return true;\r\n  } else {\r\n    return ConditionalExpression(node, parent);\r\n  }\r\n}\r\n\r\nfunction LogicalExpression(node, parent) {\r\n  switch (node.operator) {\r\n    case \"||\":\r\n      if (!isLogicalExpression(parent)) return false;\r\n      return parent.operator === \"??\" || parent.operator === \"&&\";\r\n\r\n    case \"&&\":\r\n      return isLogicalExpression(parent, {\r\n        operator: \"??\"\r\n      });\r\n\r\n    case \"??\":\r\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\r\n  }\r\n}\r\n\r\nfunction Identifier(node, parent, printStack) {\r\n  if (node.name === \"let\") {\r\n    const isFollowedByBracket = isMemberExpression(parent, {\r\n      object: node,\r\n      computed: true\r\n    }) || isOptionalMemberExpression(parent, {\r\n      object: node,\r\n      computed: true,\r\n      optional: false\r\n    });\r\n    return isFirstInContext(printStack, {\r\n      expressionStatement: isFollowedByBracket,\r\n      forHead: isFollowedByBracket,\r\n      forInHead: isFollowedByBracket,\r\n      forOfHead: true\r\n    });\r\n  }\r\n\r\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\r\n}\r\n\r\nfunction isFirstInContext(printStack, {\r\n  expressionStatement = false,\r\n  arrowBody = false,\r\n  exportDefault = false,\r\n  forHead = false,\r\n  forInHead = false,\r\n  forOfHead = false\r\n}) {\r\n  let i = printStack.length - 1;\r\n  let node = printStack[i];\r\n  i--;\r\n  let parent = printStack[i];\r\n\r\n  while (i >= 0) {\r\n    if (expressionStatement && isExpressionStatement(parent, {\r\n      expression: node\r\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\r\n      declaration: node\r\n    }) || arrowBody && isArrowFunctionExpression(parent, {\r\n      body: node\r\n    }) || forHead && isForStatement(parent, {\r\n      init: node\r\n    }) || forInHead && isForInStatement(parent, {\r\n      left: node\r\n    }) || forOfHead && isForOfStatement(parent, {\r\n      left: node\r\n    })) {\r\n      return true;\r\n    }\r\n\r\n    if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {\r\n      test: node\r\n    }) || isBinary(parent, {\r\n      left: node\r\n    }) || isAssignmentExpression(parent, {\r\n      left: node\r\n    })) {\r\n      node = parent;\r\n      i--;\r\n      parent = printStack[i];\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}