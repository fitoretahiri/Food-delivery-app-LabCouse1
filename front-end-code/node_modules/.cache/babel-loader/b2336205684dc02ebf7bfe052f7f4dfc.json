{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  identifier,\n  toExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nconst renameVisitor = {\n  ReferencedIdentifier(_ref, state) {\n    let {\n      node\n    } = _ref;\n\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(variableDeclaration(\"let\", [variableDeclarator(identifier(this.newName), toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: identifier(this.newName)\n    });\n    path.replaceWith(assignmentExpression(\"=\", identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_binding","require","_helperSplitExportDeclaration","_t","VISITOR_KEYS","assignmentExpression","identifier","toExpression","variableDeclaration","variableDeclarator","renameVisitor","ReferencedIdentifier","state","node","name","oldName","newName","Scope","path","scope","bindingIdentifierEquals","binding","skipAllButComputedMethodKey","isVariableDeclaration","ids","getOuterBindingIdentifiers","Renamer","constructor","maybeConvertFromExportDeclaration","parentDeclar","maybeExportDeclar","parentPath","isExportDeclaration","isExportDefaultDeclaration","get","id","maybeConvertFromClassFunctionDeclaration","isFunctionDeclaration","isClassDeclaration","kind","_blockHoist","replaceWith","maybeConvertFromClassFunctionExpression","isFunctionExpression","isClassExpression","parent","push","rename","block","find","isDeclaration","bindingIds","blockToTraverse","type","cases","forEach","c","traverse","removeOwnBinding","bindings","isMethod","computed","skip","keys","key","skipKey"],"sources":["C:/Users/Arber/Documents/GitHub/Food-delivery-app-LabCouse1/Food-delivery-app-LabCouse1/front-end-code/node_modules/@babel/traverse/lib/scope/lib/renamer.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _binding = require(\"../binding\");\r\n\r\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\r\n\r\nvar _t = require(\"@babel/types\");\r\n\r\nconst {\r\n  VISITOR_KEYS,\r\n  assignmentExpression,\r\n  identifier,\r\n  toExpression,\r\n  variableDeclaration,\r\n  variableDeclarator\r\n} = _t;\r\nconst renameVisitor = {\r\n  ReferencedIdentifier({\r\n    node\r\n  }, state) {\r\n    if (node.name === state.oldName) {\r\n      node.name = state.newName;\r\n    }\r\n  },\r\n\r\n  Scope(path, state) {\r\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\r\n      skipAllButComputedMethodKey(path);\r\n    }\r\n  },\r\n\r\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\r\n    if (path.isVariableDeclaration()) return;\r\n    const ids = path.getOuterBindingIdentifiers();\r\n\r\n    for (const name in ids) {\r\n      if (name === state.oldName) ids[name].name = state.newName;\r\n    }\r\n  }\r\n\r\n};\r\n\r\nclass Renamer {\r\n  constructor(binding, oldName, newName) {\r\n    this.newName = newName;\r\n    this.oldName = oldName;\r\n    this.binding = binding;\r\n  }\r\n\r\n  maybeConvertFromExportDeclaration(parentDeclar) {\r\n    const maybeExportDeclar = parentDeclar.parentPath;\r\n\r\n    if (!maybeExportDeclar.isExportDeclaration()) {\r\n      return;\r\n    }\r\n\r\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\r\n      return;\r\n    }\r\n\r\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\r\n  }\r\n\r\n  maybeConvertFromClassFunctionDeclaration(path) {\r\n    return;\r\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\r\n    if (this.binding.kind !== \"hoisted\") return;\r\n    path.node.id = identifier(this.oldName);\r\n    path.node._blockHoist = 3;\r\n    path.replaceWith(variableDeclaration(\"let\", [variableDeclarator(identifier(this.newName), toExpression(path.node))]));\r\n  }\r\n\r\n  maybeConvertFromClassFunctionExpression(path) {\r\n    return;\r\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\r\n    if (this.binding.kind !== \"local\") return;\r\n    path.node.id = identifier(this.oldName);\r\n    this.binding.scope.parent.push({\r\n      id: identifier(this.newName)\r\n    });\r\n    path.replaceWith(assignmentExpression(\"=\", identifier(this.newName), path.node));\r\n  }\r\n\r\n  rename(block) {\r\n    const {\r\n      binding,\r\n      oldName,\r\n      newName\r\n    } = this;\r\n    const {\r\n      scope,\r\n      path\r\n    } = binding;\r\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\r\n\r\n    if (parentDeclar) {\r\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\r\n\r\n      if (bindingIds[oldName] === binding.identifier) {\r\n        this.maybeConvertFromExportDeclaration(parentDeclar);\r\n      }\r\n    }\r\n\r\n    const blockToTraverse = block || scope.block;\r\n\r\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\r\n      blockToTraverse.cases.forEach(c => {\r\n        scope.traverse(c, renameVisitor, this);\r\n      });\r\n    } else {\r\n      scope.traverse(blockToTraverse, renameVisitor, this);\r\n    }\r\n\r\n    if (!block) {\r\n      scope.removeOwnBinding(oldName);\r\n      scope.bindings[newName] = binding;\r\n      this.binding.identifier.name = newName;\r\n    }\r\n\r\n    if (parentDeclar) {\r\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\r\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexports.default = Renamer;\r\n\r\nfunction skipAllButComputedMethodKey(path) {\r\n  if (!path.isMethod() || !path.node.computed) {\r\n    path.skip();\r\n    return;\r\n  }\r\n\r\n  const keys = VISITOR_KEYS[path.type];\r\n\r\n  for (const key of keys) {\r\n    if (key !== \"key\") path.skipKey(key);\r\n  }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}