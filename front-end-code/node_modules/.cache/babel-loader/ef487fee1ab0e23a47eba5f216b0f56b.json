{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"temp\";\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && kind === \"const\";\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path) {\n    let bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {\n      return true;\n    } else if (isClass(node)) {\n      var _node$decorators;\n\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      var _node$decorators2;\n\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n\n      if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {\n        return false;\n      }\n\n      return true;\n    } else if (isProperty(node)) {\n      var _node$decorators3;\n\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n\n      if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {\n        return false;\n      }\n\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {\n      kinds[_key] = arguments[_key];\n    }\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_renamer","require","_index","_binding","_globals","_t","_cache","NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isIdentifier","isImportDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isObjectExpression","isProperty","isPureish","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","isVariableDeclaration","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","isRecordExpression","isTupleExpression","isObjectProperty","isTopicReference","isMetaProperty","isPrivateName","gatherNodeParts","node","parts","type","source","specifiers","length","e","declaration","local","push","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","path","declar","get","isVar","scope","parentScope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","decl","declarations","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","Scope","constructor","block","labels","inited","globals","uids","data","crawling","cached","set","Map","_parent","isKey","parentPath","isScope","parentBlock","hub","traverse","opts","generateDeclaredUidIdentifier","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","generateUidBasedOnNode","defaultName","join","slice","generateUidIdentifierBasedOnNode","isStatic","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","buildError","TypeError","rename","oldName","newName","_renameFromMap","map","dump","sep","repeat","console","log","violations","toArray","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","registerLabel","label","isLabeledStatement","declare","specifier","buildUndefinedNode","registerConstantViolation","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","addGlobal","hasUid","isPure","constantsOnly","_node$decorators","superClass","decorators","body","method","right","elem","elements","prop","_node$decorators2","computed","_node$decorators3","static","tag","quasi","expressions","setData","val","getData","removeData","init","crawl","create","programParent","_exploded","visit","enter","typeVisitors","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","unshiftContainer","declarator","len","Error","isFunctionParent","isBlockParent","getAllBindings","getAllBindingsOfKind","kinds","bindingIdentifierEquals","getBindingIdentifier","previousPath","_previousPath","isArrowFunctionExpression","_this$getBinding","getOwnBindingIdentifier","hasOwnBinding","noGlobals","parentHasBinding","includes","contextVariables","_this$parent","moveBindingTo","info","removeOwnBinding","removeBinding","_this$getBinding2","builtin"],"sources":["C:/Users/Arber/Documents/GitHub/Food-delivery-app-LabCouse1/Food-delivery-app-LabCouse1/front-end-code/node_modules/@babel/traverse/lib/scope/index.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _renamer = require(\"./lib/renamer\");\r\n\r\nvar _index = require(\"../index\");\r\n\r\nvar _binding = require(\"./binding\");\r\n\r\nvar _globals = require(\"globals\");\r\n\r\nvar _t = require(\"@babel/types\");\r\n\r\nvar _cache = require(\"../cache\");\r\n\r\nconst {\r\n  NOT_LOCAL_BINDING,\r\n  callExpression,\r\n  cloneNode,\r\n  getBindingIdentifiers,\r\n  identifier,\r\n  isArrayExpression,\r\n  isBinary,\r\n  isClass,\r\n  isClassBody,\r\n  isClassDeclaration,\r\n  isExportAllDeclaration,\r\n  isExportDefaultDeclaration,\r\n  isExportNamedDeclaration,\r\n  isFunctionDeclaration,\r\n  isIdentifier,\r\n  isImportDeclaration,\r\n  isLiteral,\r\n  isMethod,\r\n  isModuleDeclaration,\r\n  isModuleSpecifier,\r\n  isObjectExpression,\r\n  isProperty,\r\n  isPureish,\r\n  isSuper,\r\n  isTaggedTemplateExpression,\r\n  isTemplateLiteral,\r\n  isThisExpression,\r\n  isUnaryExpression,\r\n  isVariableDeclaration,\r\n  matchesPattern,\r\n  memberExpression,\r\n  numericLiteral,\r\n  toIdentifier,\r\n  unaryExpression,\r\n  variableDeclaration,\r\n  variableDeclarator,\r\n  isRecordExpression,\r\n  isTupleExpression,\r\n  isObjectProperty,\r\n  isTopicReference,\r\n  isMetaProperty,\r\n  isPrivateName\r\n} = _t;\r\n\r\nfunction gatherNodeParts(node, parts) {\r\n  switch (node == null ? void 0 : node.type) {\r\n    default:\r\n      if (isModuleDeclaration(node)) {\r\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\r\n          gatherNodeParts(node.source, parts);\r\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\r\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\r\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\r\n          gatherNodeParts(node.declaration, parts);\r\n        }\r\n      } else if (isModuleSpecifier(node)) {\r\n        gatherNodeParts(node.local, parts);\r\n      } else if (isLiteral(node)) {\r\n        parts.push(node.value);\r\n      }\r\n\r\n      break;\r\n\r\n    case \"MemberExpression\":\r\n    case \"OptionalMemberExpression\":\r\n    case \"JSXMemberExpression\":\r\n      gatherNodeParts(node.object, parts);\r\n      gatherNodeParts(node.property, parts);\r\n      break;\r\n\r\n    case \"Identifier\":\r\n    case \"JSXIdentifier\":\r\n      parts.push(node.name);\r\n      break;\r\n\r\n    case \"CallExpression\":\r\n    case \"OptionalCallExpression\":\r\n    case \"NewExpression\":\r\n      gatherNodeParts(node.callee, parts);\r\n      break;\r\n\r\n    case \"ObjectExpression\":\r\n    case \"ObjectPattern\":\r\n      for (const e of node.properties) {\r\n        gatherNodeParts(e, parts);\r\n      }\r\n\r\n      break;\r\n\r\n    case \"SpreadElement\":\r\n    case \"RestElement\":\r\n      gatherNodeParts(node.argument, parts);\r\n      break;\r\n\r\n    case \"ObjectProperty\":\r\n    case \"ObjectMethod\":\r\n    case \"ClassProperty\":\r\n    case \"ClassMethod\":\r\n    case \"ClassPrivateProperty\":\r\n    case \"ClassPrivateMethod\":\r\n      gatherNodeParts(node.key, parts);\r\n      break;\r\n\r\n    case \"ThisExpression\":\r\n      parts.push(\"this\");\r\n      break;\r\n\r\n    case \"Super\":\r\n      parts.push(\"super\");\r\n      break;\r\n\r\n    case \"Import\":\r\n      parts.push(\"import\");\r\n      break;\r\n\r\n    case \"DoExpression\":\r\n      parts.push(\"do\");\r\n      break;\r\n\r\n    case \"YieldExpression\":\r\n      parts.push(\"yield\");\r\n      gatherNodeParts(node.argument, parts);\r\n      break;\r\n\r\n    case \"AwaitExpression\":\r\n      parts.push(\"await\");\r\n      gatherNodeParts(node.argument, parts);\r\n      break;\r\n\r\n    case \"AssignmentExpression\":\r\n      gatherNodeParts(node.left, parts);\r\n      break;\r\n\r\n    case \"VariableDeclarator\":\r\n      gatherNodeParts(node.id, parts);\r\n      break;\r\n\r\n    case \"FunctionExpression\":\r\n    case \"FunctionDeclaration\":\r\n    case \"ClassExpression\":\r\n    case \"ClassDeclaration\":\r\n      gatherNodeParts(node.id, parts);\r\n      break;\r\n\r\n    case \"PrivateName\":\r\n      gatherNodeParts(node.id, parts);\r\n      break;\r\n\r\n    case \"ParenthesizedExpression\":\r\n      gatherNodeParts(node.expression, parts);\r\n      break;\r\n\r\n    case \"UnaryExpression\":\r\n    case \"UpdateExpression\":\r\n      gatherNodeParts(node.argument, parts);\r\n      break;\r\n\r\n    case \"MetaProperty\":\r\n      gatherNodeParts(node.meta, parts);\r\n      gatherNodeParts(node.property, parts);\r\n      break;\r\n\r\n    case \"JSXElement\":\r\n      gatherNodeParts(node.openingElement, parts);\r\n      break;\r\n\r\n    case \"JSXOpeningElement\":\r\n      parts.push(node.name);\r\n      break;\r\n\r\n    case \"JSXFragment\":\r\n      gatherNodeParts(node.openingFragment, parts);\r\n      break;\r\n\r\n    case \"JSXOpeningFragment\":\r\n      parts.push(\"Fragment\");\r\n      break;\r\n\r\n    case \"JSXNamespacedName\":\r\n      gatherNodeParts(node.namespace, parts);\r\n      gatherNodeParts(node.name, parts);\r\n      break;\r\n  }\r\n}\r\n\r\nconst collectorVisitor = {\r\n  ForStatement(path) {\r\n    const declar = path.get(\"init\");\r\n\r\n    if (declar.isVar()) {\r\n      const {\r\n        scope\r\n      } = path;\r\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\r\n      parentScope.registerBinding(\"var\", declar);\r\n    }\r\n  },\r\n\r\n  Declaration(path) {\r\n    if (path.isBlockScoped()) return;\r\n    if (path.isImportDeclaration()) return;\r\n    if (path.isExportDeclaration()) return;\r\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\r\n    parent.registerDeclaration(path);\r\n  },\r\n\r\n  ImportDeclaration(path) {\r\n    const parent = path.scope.getBlockParent();\r\n    parent.registerDeclaration(path);\r\n  },\r\n\r\n  ReferencedIdentifier(path, state) {\r\n    state.references.push(path);\r\n  },\r\n\r\n  ForXStatement(path, state) {\r\n    const left = path.get(\"left\");\r\n\r\n    if (left.isPattern() || left.isIdentifier()) {\r\n      state.constantViolations.push(path);\r\n    } else if (left.isVar()) {\r\n      const {\r\n        scope\r\n      } = path;\r\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\r\n      parentScope.registerBinding(\"var\", left);\r\n    }\r\n  },\r\n\r\n  ExportDeclaration: {\r\n    exit(path) {\r\n      const {\r\n        node,\r\n        scope\r\n      } = path;\r\n      if (isExportAllDeclaration(node)) return;\r\n      const declar = node.declaration;\r\n\r\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\r\n        const id = declar.id;\r\n        if (!id) return;\r\n        const binding = scope.getBinding(id.name);\r\n        binding == null ? void 0 : binding.reference(path);\r\n      } else if (isVariableDeclaration(declar)) {\r\n        for (const decl of declar.declarations) {\r\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\r\n            const binding = scope.getBinding(name);\r\n            binding == null ? void 0 : binding.reference(path);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n  },\r\n\r\n  LabeledStatement(path) {\r\n    path.scope.getBlockParent().registerDeclaration(path);\r\n  },\r\n\r\n  AssignmentExpression(path, state) {\r\n    state.assignments.push(path);\r\n  },\r\n\r\n  UpdateExpression(path, state) {\r\n    state.constantViolations.push(path);\r\n  },\r\n\r\n  UnaryExpression(path, state) {\r\n    if (path.node.operator === \"delete\") {\r\n      state.constantViolations.push(path);\r\n    }\r\n  },\r\n\r\n  BlockScoped(path) {\r\n    let scope = path.scope;\r\n    if (scope.path === path) scope = scope.parent;\r\n    const parent = scope.getBlockParent();\r\n    parent.registerDeclaration(path);\r\n\r\n    if (path.isClassDeclaration() && path.node.id) {\r\n      const id = path.node.id;\r\n      const name = id.name;\r\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\r\n    }\r\n  },\r\n\r\n  CatchClause(path) {\r\n    path.scope.registerBinding(\"let\", path);\r\n  },\r\n\r\n  Function(path) {\r\n    const params = path.get(\"params\");\r\n\r\n    for (const param of params) {\r\n      path.scope.registerBinding(\"param\", param);\r\n    }\r\n\r\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\r\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\r\n    }\r\n  },\r\n\r\n  ClassExpression(path) {\r\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\r\n      path.scope.registerBinding(\"local\", path);\r\n    }\r\n  }\r\n\r\n};\r\nlet uid = 0;\r\n\r\nclass Scope {\r\n  constructor(path) {\r\n    this.uid = void 0;\r\n    this.path = void 0;\r\n    this.block = void 0;\r\n    this.labels = void 0;\r\n    this.inited = void 0;\r\n    this.bindings = void 0;\r\n    this.references = void 0;\r\n    this.globals = void 0;\r\n    this.uids = void 0;\r\n    this.data = void 0;\r\n    this.crawling = void 0;\r\n    const {\r\n      node\r\n    } = path;\r\n\r\n    const cached = _cache.scope.get(node);\r\n\r\n    if ((cached == null ? void 0 : cached.path) === path) {\r\n      return cached;\r\n    }\r\n\r\n    _cache.scope.set(node, this);\r\n\r\n    this.uid = uid++;\r\n    this.block = node;\r\n    this.path = path;\r\n    this.labels = new Map();\r\n    this.inited = false;\r\n  }\r\n\r\n  get parent() {\r\n    var _parent;\r\n\r\n    let parent,\r\n        path = this.path;\r\n\r\n    do {\r\n      const isKey = path.key === \"key\";\r\n      path = path.parentPath;\r\n      if (isKey && path.isMethod()) path = path.parentPath;\r\n      if (path && path.isScope()) parent = path;\r\n    } while (path && !parent);\r\n\r\n    return (_parent = parent) == null ? void 0 : _parent.scope;\r\n  }\r\n\r\n  get parentBlock() {\r\n    return this.path.parent;\r\n  }\r\n\r\n  get hub() {\r\n    return this.path.hub;\r\n  }\r\n\r\n  traverse(node, opts, state) {\r\n    (0, _index.default)(node, opts, this, state, this.path);\r\n  }\r\n\r\n  generateDeclaredUidIdentifier(name) {\r\n    const id = this.generateUidIdentifier(name);\r\n    this.push({\r\n      id\r\n    });\r\n    return cloneNode(id);\r\n  }\r\n\r\n  generateUidIdentifier(name) {\r\n    return identifier(this.generateUid(name));\r\n  }\r\n\r\n  generateUid(name = \"temp\") {\r\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\r\n    let uid;\r\n    let i = 1;\r\n\r\n    do {\r\n      uid = this._generateUid(name, i);\r\n      i++;\r\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\r\n\r\n    const program = this.getProgramParent();\r\n    program.references[uid] = true;\r\n    program.uids[uid] = true;\r\n    return uid;\r\n  }\r\n\r\n  _generateUid(name, i) {\r\n    let id = name;\r\n    if (i > 1) id += i;\r\n    return `_${id}`;\r\n  }\r\n\r\n  generateUidBasedOnNode(node, defaultName) {\r\n    const parts = [];\r\n    gatherNodeParts(node, parts);\r\n    let id = parts.join(\"$\");\r\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\r\n    return this.generateUid(id.slice(0, 20));\r\n  }\r\n\r\n  generateUidIdentifierBasedOnNode(node, defaultName) {\r\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\r\n  }\r\n\r\n  isStatic(node) {\r\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\r\n      return true;\r\n    }\r\n\r\n    if (isIdentifier(node)) {\r\n      const binding = this.getBinding(node.name);\r\n\r\n      if (binding) {\r\n        return binding.constant;\r\n      } else {\r\n        return this.hasBinding(node.name);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  maybeGenerateMemoised(node, dontPush) {\r\n    if (this.isStatic(node)) {\r\n      return null;\r\n    } else {\r\n      const id = this.generateUidIdentifierBasedOnNode(node);\r\n\r\n      if (!dontPush) {\r\n        this.push({\r\n          id\r\n        });\r\n        return cloneNode(id);\r\n      }\r\n\r\n      return id;\r\n    }\r\n  }\r\n\r\n  checkBlockScopedCollisions(local, kind, name, id) {\r\n    if (kind === \"param\") return;\r\n    if (local.kind === \"local\") return;\r\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && kind === \"const\";\r\n\r\n    if (duplicate) {\r\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\r\n    }\r\n  }\r\n\r\n  rename(oldName, newName, block) {\r\n    const binding = this.getBinding(oldName);\r\n\r\n    if (binding) {\r\n      newName = newName || this.generateUidIdentifier(oldName).name;\r\n      return new _renamer.default(binding, oldName, newName).rename(block);\r\n    }\r\n  }\r\n\r\n  _renameFromMap(map, oldName, newName, value) {\r\n    if (map[oldName]) {\r\n      map[newName] = value;\r\n      map[oldName] = null;\r\n    }\r\n  }\r\n\r\n  dump() {\r\n    const sep = \"-\".repeat(60);\r\n    console.log(sep);\r\n    let scope = this;\r\n\r\n    do {\r\n      console.log(\"#\", scope.block.type);\r\n\r\n      for (const name of Object.keys(scope.bindings)) {\r\n        const binding = scope.bindings[name];\r\n        console.log(\" -\", name, {\r\n          constant: binding.constant,\r\n          references: binding.references,\r\n          violations: binding.constantViolations.length,\r\n          kind: binding.kind\r\n        });\r\n      }\r\n    } while (scope = scope.parent);\r\n\r\n    console.log(sep);\r\n  }\r\n\r\n  toArray(node, i, arrayLikeIsIterable) {\r\n    if (isIdentifier(node)) {\r\n      const binding = this.getBinding(node.name);\r\n\r\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\r\n        return node;\r\n      }\r\n    }\r\n\r\n    if (isArrayExpression(node)) {\r\n      return node;\r\n    }\r\n\r\n    if (isIdentifier(node, {\r\n      name: \"arguments\"\r\n    })) {\r\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\r\n    }\r\n\r\n    let helperName;\r\n    const args = [node];\r\n\r\n    if (i === true) {\r\n      helperName = \"toConsumableArray\";\r\n    } else if (i) {\r\n      args.push(numericLiteral(i));\r\n      helperName = \"slicedToArray\";\r\n    } else {\r\n      helperName = \"toArray\";\r\n    }\r\n\r\n    if (arrayLikeIsIterable) {\r\n      args.unshift(this.hub.addHelper(helperName));\r\n      helperName = \"maybeArrayLike\";\r\n    }\r\n\r\n    return callExpression(this.hub.addHelper(helperName), args);\r\n  }\r\n\r\n  hasLabel(name) {\r\n    return !!this.getLabel(name);\r\n  }\r\n\r\n  getLabel(name) {\r\n    return this.labels.get(name);\r\n  }\r\n\r\n  registerLabel(path) {\r\n    this.labels.set(path.node.label.name, path);\r\n  }\r\n\r\n  registerDeclaration(path) {\r\n    if (path.isLabeledStatement()) {\r\n      this.registerLabel(path);\r\n    } else if (path.isFunctionDeclaration()) {\r\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\r\n    } else if (path.isVariableDeclaration()) {\r\n      const declarations = path.get(\"declarations\");\r\n\r\n      for (const declar of declarations) {\r\n        this.registerBinding(path.node.kind, declar);\r\n      }\r\n    } else if (path.isClassDeclaration()) {\r\n      if (path.node.declare) return;\r\n      this.registerBinding(\"let\", path);\r\n    } else if (path.isImportDeclaration()) {\r\n      const specifiers = path.get(\"specifiers\");\r\n\r\n      for (const specifier of specifiers) {\r\n        this.registerBinding(\"module\", specifier);\r\n      }\r\n    } else if (path.isExportDeclaration()) {\r\n      const declar = path.get(\"declaration\");\r\n\r\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\r\n        this.registerDeclaration(declar);\r\n      }\r\n    } else {\r\n      this.registerBinding(\"unknown\", path);\r\n    }\r\n  }\r\n\r\n  buildUndefinedNode() {\r\n    return unaryExpression(\"void\", numericLiteral(0), true);\r\n  }\r\n\r\n  registerConstantViolation(path) {\r\n    const ids = path.getBindingIdentifiers();\r\n\r\n    for (const name of Object.keys(ids)) {\r\n      const binding = this.getBinding(name);\r\n      if (binding) binding.reassign(path);\r\n    }\r\n  }\r\n\r\n  registerBinding(kind, path, bindingPath = path) {\r\n    if (!kind) throw new ReferenceError(\"no `kind`\");\r\n\r\n    if (path.isVariableDeclaration()) {\r\n      const declarators = path.get(\"declarations\");\r\n\r\n      for (const declar of declarators) {\r\n        this.registerBinding(kind, declar);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const parent = this.getProgramParent();\r\n    const ids = path.getOuterBindingIdentifiers(true);\r\n\r\n    for (const name of Object.keys(ids)) {\r\n      parent.references[name] = true;\r\n\r\n      for (const id of ids[name]) {\r\n        const local = this.getOwnBinding(name);\r\n\r\n        if (local) {\r\n          if (local.identifier === id) continue;\r\n          this.checkBlockScopedCollisions(local, kind, name, id);\r\n        }\r\n\r\n        if (local) {\r\n          this.registerConstantViolation(bindingPath);\r\n        } else {\r\n          this.bindings[name] = new _binding.default({\r\n            identifier: id,\r\n            scope: this,\r\n            path: bindingPath,\r\n            kind: kind\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  addGlobal(node) {\r\n    this.globals[node.name] = node;\r\n  }\r\n\r\n  hasUid(name) {\r\n    let scope = this;\r\n\r\n    do {\r\n      if (scope.uids[name]) return true;\r\n    } while (scope = scope.parent);\r\n\r\n    return false;\r\n  }\r\n\r\n  hasGlobal(name) {\r\n    let scope = this;\r\n\r\n    do {\r\n      if (scope.globals[name]) return true;\r\n    } while (scope = scope.parent);\r\n\r\n    return false;\r\n  }\r\n\r\n  hasReference(name) {\r\n    return !!this.getProgramParent().references[name];\r\n  }\r\n\r\n  isPure(node, constantsOnly) {\r\n    if (isIdentifier(node)) {\r\n      const binding = this.getBinding(node.name);\r\n      if (!binding) return false;\r\n      if (constantsOnly) return binding.constant;\r\n      return true;\r\n    } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {\r\n      return true;\r\n    } else if (isClass(node)) {\r\n      var _node$decorators;\r\n\r\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\r\n        return false;\r\n      }\r\n\r\n      if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {\r\n        return false;\r\n      }\r\n\r\n      return this.isPure(node.body, constantsOnly);\r\n    } else if (isClassBody(node)) {\r\n      for (const method of node.body) {\r\n        if (!this.isPure(method, constantsOnly)) return false;\r\n      }\r\n\r\n      return true;\r\n    } else if (isBinary(node)) {\r\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\r\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\r\n      for (const elem of node.elements) {\r\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\r\n      }\r\n\r\n      return true;\r\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\r\n      for (const prop of node.properties) {\r\n        if (!this.isPure(prop, constantsOnly)) return false;\r\n      }\r\n\r\n      return true;\r\n    } else if (isMethod(node)) {\r\n      var _node$decorators2;\r\n\r\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\r\n\r\n      if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } else if (isProperty(node)) {\r\n      var _node$decorators3;\r\n\r\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\r\n\r\n      if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {\r\n        return false;\r\n      }\r\n\r\n      if (isObjectProperty(node) || node.static) {\r\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    } else if (isUnaryExpression(node)) {\r\n      return this.isPure(node.argument, constantsOnly);\r\n    } else if (isTaggedTemplateExpression(node)) {\r\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\r\n    } else if (isTemplateLiteral(node)) {\r\n      for (const expression of node.expressions) {\r\n        if (!this.isPure(expression, constantsOnly)) return false;\r\n      }\r\n\r\n      return true;\r\n    } else {\r\n      return isPureish(node);\r\n    }\r\n  }\r\n\r\n  setData(key, val) {\r\n    return this.data[key] = val;\r\n  }\r\n\r\n  getData(key) {\r\n    let scope = this;\r\n\r\n    do {\r\n      const data = scope.data[key];\r\n      if (data != null) return data;\r\n    } while (scope = scope.parent);\r\n  }\r\n\r\n  removeData(key) {\r\n    let scope = this;\r\n\r\n    do {\r\n      const data = scope.data[key];\r\n      if (data != null) scope.data[key] = null;\r\n    } while (scope = scope.parent);\r\n  }\r\n\r\n  init() {\r\n    if (!this.inited) {\r\n      this.inited = true;\r\n      this.crawl();\r\n    }\r\n  }\r\n\r\n  crawl() {\r\n    const path = this.path;\r\n    this.references = Object.create(null);\r\n    this.bindings = Object.create(null);\r\n    this.globals = Object.create(null);\r\n    this.uids = Object.create(null);\r\n    this.data = Object.create(null);\r\n    const programParent = this.getProgramParent();\r\n    if (programParent.crawling) return;\r\n    const state = {\r\n      references: [],\r\n      constantViolations: [],\r\n      assignments: []\r\n    };\r\n    this.crawling = true;\r\n\r\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\r\n      for (const visit of collectorVisitor.enter) {\r\n        visit(path, state);\r\n      }\r\n\r\n      const typeVisitors = collectorVisitor[path.type];\r\n\r\n      if (typeVisitors) {\r\n        for (const visit of typeVisitors.enter) {\r\n          visit(path, state);\r\n        }\r\n      }\r\n    }\r\n\r\n    path.traverse(collectorVisitor, state);\r\n    this.crawling = false;\r\n\r\n    for (const path of state.assignments) {\r\n      const ids = path.getBindingIdentifiers();\r\n\r\n      for (const name of Object.keys(ids)) {\r\n        if (path.scope.getBinding(name)) continue;\r\n        programParent.addGlobal(ids[name]);\r\n      }\r\n\r\n      path.scope.registerConstantViolation(path);\r\n    }\r\n\r\n    for (const ref of state.references) {\r\n      const binding = ref.scope.getBinding(ref.node.name);\r\n\r\n      if (binding) {\r\n        binding.reference(ref);\r\n      } else {\r\n        programParent.addGlobal(ref.node);\r\n      }\r\n    }\r\n\r\n    for (const path of state.constantViolations) {\r\n      path.scope.registerConstantViolation(path);\r\n    }\r\n  }\r\n\r\n  push(opts) {\r\n    let path = this.path;\r\n\r\n    if (!path.isBlockStatement() && !path.isProgram()) {\r\n      path = this.getBlockParent().path;\r\n    }\r\n\r\n    if (path.isSwitchStatement()) {\r\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\r\n    }\r\n\r\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\r\n      path.ensureBlock();\r\n      path = path.get(\"body\");\r\n    }\r\n\r\n    const unique = opts.unique;\r\n    const kind = opts.kind || \"var\";\r\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\r\n    const dataKey = `declaration:${kind}:${blockHoist}`;\r\n    let declarPath = !unique && path.getData(dataKey);\r\n\r\n    if (!declarPath) {\r\n      const declar = variableDeclaration(kind, []);\r\n      declar._blockHoist = blockHoist;\r\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\r\n      if (!unique) path.setData(dataKey, declarPath);\r\n    }\r\n\r\n    const declarator = variableDeclarator(opts.id, opts.init);\r\n    const len = declarPath.node.declarations.push(declarator);\r\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\r\n  }\r\n\r\n  getProgramParent() {\r\n    let scope = this;\r\n\r\n    do {\r\n      if (scope.path.isProgram()) {\r\n        return scope;\r\n      }\r\n    } while (scope = scope.parent);\r\n\r\n    throw new Error(\"Couldn't find a Program\");\r\n  }\r\n\r\n  getFunctionParent() {\r\n    let scope = this;\r\n\r\n    do {\r\n      if (scope.path.isFunctionParent()) {\r\n        return scope;\r\n      }\r\n    } while (scope = scope.parent);\r\n\r\n    return null;\r\n  }\r\n\r\n  getBlockParent() {\r\n    let scope = this;\r\n\r\n    do {\r\n      if (scope.path.isBlockParent()) {\r\n        return scope;\r\n      }\r\n    } while (scope = scope.parent);\r\n\r\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\r\n  }\r\n\r\n  getAllBindings() {\r\n    const ids = Object.create(null);\r\n    let scope = this;\r\n\r\n    do {\r\n      for (const key of Object.keys(scope.bindings)) {\r\n        if (key in ids === false) {\r\n          ids[key] = scope.bindings[key];\r\n        }\r\n      }\r\n\r\n      scope = scope.parent;\r\n    } while (scope);\r\n\r\n    return ids;\r\n  }\r\n\r\n  getAllBindingsOfKind(...kinds) {\r\n    const ids = Object.create(null);\r\n\r\n    for (const kind of kinds) {\r\n      let scope = this;\r\n\r\n      do {\r\n        for (const name of Object.keys(scope.bindings)) {\r\n          const binding = scope.bindings[name];\r\n          if (binding.kind === kind) ids[name] = binding;\r\n        }\r\n\r\n        scope = scope.parent;\r\n      } while (scope);\r\n    }\r\n\r\n    return ids;\r\n  }\r\n\r\n  bindingIdentifierEquals(name, node) {\r\n    return this.getBindingIdentifier(name) === node;\r\n  }\r\n\r\n  getBinding(name) {\r\n    let scope = this;\r\n    let previousPath;\r\n\r\n    do {\r\n      const binding = scope.getOwnBinding(name);\r\n\r\n      if (binding) {\r\n        var _previousPath;\r\n\r\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\r\n          return binding;\r\n        }\r\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\r\n        break;\r\n      }\r\n\r\n      previousPath = scope.path;\r\n    } while (scope = scope.parent);\r\n  }\r\n\r\n  getOwnBinding(name) {\r\n    return this.bindings[name];\r\n  }\r\n\r\n  getBindingIdentifier(name) {\r\n    var _this$getBinding;\r\n\r\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\r\n  }\r\n\r\n  getOwnBindingIdentifier(name) {\r\n    const binding = this.bindings[name];\r\n    return binding == null ? void 0 : binding.identifier;\r\n  }\r\n\r\n  hasOwnBinding(name) {\r\n    return !!this.getOwnBinding(name);\r\n  }\r\n\r\n  hasBinding(name, noGlobals) {\r\n    if (!name) return false;\r\n    if (this.hasOwnBinding(name)) return true;\r\n    if (this.parentHasBinding(name, noGlobals)) return true;\r\n    if (this.hasUid(name)) return true;\r\n    if (!noGlobals && Scope.globals.includes(name)) return true;\r\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\r\n    return false;\r\n  }\r\n\r\n  parentHasBinding(name, noGlobals) {\r\n    var _this$parent;\r\n\r\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\r\n  }\r\n\r\n  moveBindingTo(name, scope) {\r\n    const info = this.getBinding(name);\r\n\r\n    if (info) {\r\n      info.scope.removeOwnBinding(name);\r\n      info.scope = scope;\r\n      scope.bindings[name] = info;\r\n    }\r\n  }\r\n\r\n  removeOwnBinding(name) {\r\n    delete this.bindings[name];\r\n  }\r\n\r\n  removeBinding(name) {\r\n    var _this$getBinding2;\r\n\r\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\r\n    let scope = this;\r\n\r\n    do {\r\n      if (scope.uids[name]) {\r\n        scope.uids[name] = false;\r\n      }\r\n    } while (scope = scope.parent);\r\n  }\r\n\r\n}\r\n\r\nexports.default = Scope;\r\nScope.globals = Object.keys(_globals.builtin);\r\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];"],"mappings":"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"},"metadata":{},"sourceType":"script"}